{"componentChunkName":"component---src-templates-blog-post-js","path":"/machine-learning/2016/11/02/understanding-XOR-with-keras-and-tensorlow.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"6de4579a-42e7-5fe9-80d6-130a3c530157","excerpt":"In our recent article on machine learning we’ve shown how to get started with machine learning without assuming any prior knowledge. We ended up running our…","html":"<p>In our <a href=\"/machine-learning/2016/09/23/beginning-ml-with-keras-and-tensorflow.html\">recent article</a> on machine learning we’ve shown how to get started with machine learning without assuming any prior knowledge. We ended up running our very first neural network to implement an <a href=\"https://en.wikipedia.org/wiki/XOR_gate\">XOR gate</a>.</p>\n<p>Of course solving XOR is a toy task. Why would you use a neural network to solve a trivial task that a hash map could solve much faster? The answer is simple: When we learn something new, we want to start with bite-sized tasks and take away as much of the complexity as possible. Once we grokked the basics, we can work our way up to the more advanced stuff.</p>\n<p>As an absolute machine learning beginner you’re probably still wondering what the code means and how you could have come up with it by yourself. What are all these numbers and what role do they play in solving the XOR problem? If these are youre questions, read on!</p>\n<h2>Understanding the model of our neural net</h2>\n<p>Let’s take another look at our model from the previous article. We’ll be exploring what it actually means line by line.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">from</span> keras<span class=\"token punctuation\">.</span>models <span class=\"token keyword\">import</span> Sequential\n<span class=\"token keyword\">from</span> keras<span class=\"token punctuation\">.</span>layers<span class=\"token punctuation\">.</span>core <span class=\"token keyword\">import</span> Dense\n\n<span class=\"token comment\"># the four different states of the XOR gate</span>\ntraining_data <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"float32\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># the four expected results in the same order</span>\ntarget_data <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"float32\"</span><span class=\"token punctuation\">)</span>\n\nmodel <span class=\"token operator\">=</span> Sequential<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span> input_dim<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'relu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'sigmoid'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\nmodel<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'mean_squared_error'</span><span class=\"token punctuation\">,</span>\n              optimizer<span class=\"token operator\">=</span><span class=\"token string\">'adam'</span><span class=\"token punctuation\">,</span>\n              metrics<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'binary_accuracy'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\nmodel<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>training_data<span class=\"token punctuation\">,</span> target_data<span class=\"token punctuation\">,</span> nb_epoch<span class=\"token operator\">=</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> verbose<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span> model<span class=\"token punctuation\">.</span>predict<span class=\"token punctuation\">(</span>training_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">round</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Let’s focus on the list of imports first. These are all things that we need to bring into scope because we need them in the rest of the code.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">from</span> keras<span class=\"token punctuation\">.</span>models <span class=\"token keyword\">import</span> Sequential\n<span class=\"token keyword\">from</span> keras<span class=\"token punctuation\">.</span>layers<span class=\"token punctuation\">.</span>core <span class=\"token keyword\">import</span> Dense</code></pre></div>\n<p>The Python ecosystem has pretty strong math support. One of the most popular libraries is <code class=\"language-text\">numpy</code> which makes working with arrays a joy. <a href=\"https://keras.io/\">Keras</a> also uses numpy internally and expects numpy arrays as inputs. We import <code class=\"language-text\">numpy</code> and alias it as <code class=\"language-text\">np</code> which is pretty common thing to do when writing this kind of code.</p>\n<p>Keras offers two different APIs to construct a model: a <em>functional</em> and a <em>sequential</em> one. We’re using the sequential API hence the second import of <code class=\"language-text\">Sequential</code> from <code class=\"language-text\">keras.models</code>.</p>\n<p>Neural networks consist of different layers where input data flows through and gets transformed on its way. There are a bunch of different layer types available in Keras. These different types of layer help us to model individual kinds of neural nets for various machine learning tasks. In our specific case the <code class=\"language-text\">Dense</code> layer is what we want. We’ll explain it in more detail later on.</p>\n<p>What follows are two sets of data.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token comment\"># the four different states of the XOR gate</span>\ntraining_data <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"float32\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># the four expected results in the same order</span>\ntarget_data <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"float32\"</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We initialize <code class=\"language-text\">training_data</code> as a two-dimensional array (an array of arrays) where each of the inner arrays has exactly two items. As we’ve already described in the previous article, each of these pairs has a corresponding expected result. That’s why we could solve the whole task with a simple hash map but let’s carry on.</p>\n<p>We setup <code class=\"language-text\">target_data</code> as another two-dimensional array. All the inner arrays in <code class=\"language-text\">target_data</code> contain just a single item though. Each inner array of <code class=\"language-text\">training_data</code> relates to its counterpart in <code class=\"language-text\">target_data</code>. At least, that’s essentially what we want the neural net to learn over time. The value <code class=\"language-text\">[0, 0]</code> means <code class=\"language-text\">0</code>, <code class=\"language-text\">[0, 1]</code> means <code class=\"language-text\">1</code> and so on and so forth.</p>\n<p>Let’s get to the most interesting part, the model!</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model <span class=\"token operator\">=</span> Sequential<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">,</span> input_dim<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'relu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'sigmoid'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The first line sets up an empty model using the <code class=\"language-text\">Sequential</code> API. But what’s going on in the second line?</p>\n<p>We’re adding a <code class=\"language-text\">Dense</code> layer to our model which we’ll explain in more detail a bit later. For now, let’s focus on its configuration.  We set <code class=\"language-text\">input_dim=2</code> because each of our input samples is an array of length <code class=\"language-text\">2</code> (<code class=\"language-text\">[0, 1]</code>, <code class=\"language-text\">[1, 0]</code> etc.). If we had input data such as <code class=\"language-text\">[0, 1, 1]</code> our <code class=\"language-text\">input_dim</code> would be <code class=\"language-text\">3</code>. You get the idea.</p>\n<p>The more interesting question is: What does the <code class=\"language-text\">16</code> stand for? It’s the dimension of the output for this layer. If we think about our model in terms of neurons it means that we have two input neurons (<code class=\"language-text\">input_dim=2</code>) spreading into 16 neurons in a so called hidden layer.</p>\n<p>We also added another layer with an output dimension of <code class=\"language-text\">1</code> and without an explicit input dimension. In this case the input dimension is implicitly bound to be <code class=\"language-text\">16</code> since that’s the output dimension of the previous layer.</p>\n<p>We can visualize our model like this.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 438px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.15068493150686%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsSAAALEgHS3X78AAADu0lEQVQ4y5VUe0xTZxS/rQ98IiIhZsHgjEWyh4n+s2TBP4yGuSWL2xL2D8m2bMsSoyMbxi3RbLgti6IQyXDASiBSKErQFqilBam3b2wdreXdSiktLQpYr1Y7iuDOzrlyy1zZMm9ycs53zj3n+53HdxjmP75DhSficlNH95uXu+y5wvm8TMG80HfsZDHj8EfEJHfY3Ud7J2Zg+N6f0NXjrSQdAIiqm9SJjmXFR+OywyRnnGY5L5dK5YJ6pWXojtc8OAE65+icfST8VHpJvZkM7dYBUULAec7Gc1+/SgTgEwOMiQODV/HHJELB29qMrmbfY7QiGfrG7ajiAzVfsy2d3oOgPuEmr0sp6DauS96QqrUNF3TYPUX5nx/OWEh56WBjiIy4QSPNDPt1tUgXzJ01W0knkWzbiGx9m8mVct3pO23qD57/+Zea14SAZ+q/F8tNvy2Xas7xMfxwa/EmRGkAGAYiLsBaULX2pYwt6WTT9wZafY8APPcBjP1Bd2paeuo/gakHLi5m+c1XH62dmbKEHt8xwaMJI3DjbGTXzuxX0bQOKQWb4r7hmQJMGW6O3o8d+fa7l8mvorVkp4ytKChp/GEHnTtHLosQoZcfjfEhdeEcZ4vNc/bZkFtzjGqX+9Z+SpmRtVwvwEDRnrGHT1Tm3lLS/SQ9vlfplEWNEypQOuu4ksYfs+IIhbSN2upcrOU7JK9elZSGLD1zmySZzjXN2j31bez7gk+xrOiizqeAcsVpjniDserLZ8Hm+sQLzfn0SfhGGIkLDKq/QFWSJGt7JnKx1ub+oNszNWkbuRfROUYIPXP83NcftvU1ABtoBYWjLlZ+5dTrcYSf5L+7embaGqAaPhjXAzYovEOylWq4EmkNe2vMc5sDcAWjYHVPxvI/O7Sd/Ko1ZTlyU1XRry3Fu+hsndIsNiYSMtjg6QDAfD8FxP4zaeuTU7YQ0mu/32aDszjyUQDL0F3f7jdyNhHyv3e5e1r7LNikt5M32Nm6Vx6GDAqkFoepgZ+17OwsctxwqrxWonf5K3Fk6vHV7Ebdsn1vH1wBEBY122uXyfQV4ueGPTppTngpsWmLoKOZW4XD/XF792DhgYN5a6gU//pScJB57h+4KqYNQoRj89yNStZxYRQHmwhfDEtDv7DeEpdD3nv70XGGl7tUlYxOxW8n5mxVvfBLEtUNA8EV3c1Z6/BdKKtpylhYDqL/vQ9pffWG/uCRYlNOusOIMMIjvCSgb2w3vdiSLZU2xmUl23MAG5KXszd3BZ0x2JLo/gKqHxyCmtTYEwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"xor model\"\n        title=\"xor model\"\n        src=\"/static/1446993cad12b4ee1e076cbbdd912de0/f4471/xor_model.png\"\n        srcset=\"/static/1446993cad12b4ee1e076cbbdd912de0/9ec3c/xor_model.png 200w,\n/static/1446993cad12b4ee1e076cbbdd912de0/c7805/xor_model.png 400w,\n/static/1446993cad12b4ee1e076cbbdd912de0/f4471/xor_model.png 438w\"\n        sizes=\"(max-width: 438px) 100vw, 438px\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>Let’s just take it as this for now. We’ll come back to look at what the number of neurons means in a moment.</p>\n<p>But there’s one more thing in the current snippet that may scare us: <code class=\"language-text\">activation=&#39;relu&#39;</code>. What does that mean? Do we finally have to talk about the scary math? Not really! Remember that neural networks are all about taking your inputs and transforming them into some output. Obviously there has to be some sort of math in between. There also need to be some moving parts, otherwise there wouldn’t be a chance for the model to learn anything. The moving parts are the so called weights and a <strong>simplified</strong> version of the math looks roughly like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">output <span class=\"token operator\">=</span> activation<span class=\"token punctuation\">(</span><span class=\"token builtin\">input</span> x weight<span class=\"token punctuation\">)</span></code></pre></div>\n<p>By setting <code class=\"language-text\">activation=&#39;relu&#39;</code> we specify that we want to use the <a href=\"https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\">relu</a> function as the activation function. But really it doesn’t matter as much as you may think. We could totally change this to use the <a href=\"https://en.wikipedia.org/wiki/Sigmoid_function\">sigmoid</a> function and it would still work. We could even use no activation function at all so that our algorithm essentially becomes.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">output <span class=\"token operator\">=</span> <span class=\"token builtin\">input</span> x weight</code></pre></div>\n<p>Yes, that’s right. You can solve the XOR problem even without any activation function at all. It would just take much more time to train the model. Please don’t get us wrong. We aren’t saying the activation function doesn’t matter. In fact it matters a lot. But for our specific task which is very trivial, it matters less than people may think when they see the code for the very first time.</p>\n<p>There’s one last thing we have to do before we can start training our model. We have to configure the learning process by calling <code class=\"language-text\">model.compile(...)</code> with a set of parameters.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'mean_squared_error'</span><span class=\"token punctuation\">,</span>\n              optimizer<span class=\"token operator\">=</span><span class=\"token string\">'adam'</span><span class=\"token punctuation\">,</span>\n              metrics<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">'binary_accuracy'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In order for the neural network to be able to make the right adjustments to the weights we need to be able to tell how good our model is performing. Or to be more specific, with neural nets we always want to calculate a number that tells us how bad our model performs and then try to get that number lower.</p>\n<p>That number is the so called <em>loss</em> and we can decide how the loss is calculated. Similar to how we picked <code class=\"language-text\">relu</code> as our activation function we picked <code class=\"language-text\">mean_squared_error</code> as our loss function simply because it’s a well proven loss function. We could change it to <code class=\"language-text\">binary_crossentropy</code> and our model would still continue to work. Again, we aren’t saying all loss functions can be used interchangeably. They do serve specific use cases. It’s just that we don’t have to understand all the heavy math behind each function to get going!</p>\n<p>That brings us to the next parameter, the optimizer. The job of the optimizer is it to find the right adjustments for the weights. I’m sure by now you may guess how we picked <code class=\"language-text\">adam</code> as our optimizer of choice. Right, because it’s a well proven one!</p>\n<p>The third parameter, <code class=\"language-text\">metrics</code> is actually much more interesting for our learning efforts. Here we can specify which metrics to collect during the training. We are interested in the <code class=\"language-text\">binary_accuracy</code> which gives us access to a number that tells us exactly how accurate our predictions are. More on that later.</p>\n<p>And that’s all we have to set up before we can start training our model. We kick off the training by calling <code class=\"language-text\">model.fit(...)</code> with a bunch of parameters.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model<span class=\"token punctuation\">.</span>fit<span class=\"token punctuation\">(</span>training_data<span class=\"token punctuation\">,</span> target_data<span class=\"token punctuation\">,</span> nb_epoch<span class=\"token operator\">=</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> verbose<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The first two params are training and target data, the third one is the number of epochs (learning iterations) and the last one tells keras how much info to print out during the training.</p>\n<p>Once the training phase finished we can start making predictions.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">print</span> model<span class=\"token punctuation\">.</span>predict<span class=\"token punctuation\">(</span>training_data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">round</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Please note that in a real world scenario our predictions would be tested against data that the neural network hasn’t seen during the training. That’s because we usually want to see if our model generalizes well. In other words, does it work with new data or does it just memorize all the data and expected results it had seen in the training phase? However, with this toy task there are really only our four states and four expected outputs. No way to proof generalization here.</p>\n<p>Also note that we are rounding the output to get clear binary answers. Neural networks  calculate probabilities. If we wouldn’t round we would see something like <code class=\"language-text\">0.9993...</code> and <code class=\"language-text\">0.00034...</code> instead of <code class=\"language-text\">1</code> and <code class=\"language-text\">0</code> which isn’t exactly what we want.</p>\n<h2>Finding the right model</h2>\n<p>Now that we know what all those numbers mean. Let’s take a closer look at how we configured the layers. Why did we pick the <code class=\"language-text\">Dense</code> layer in the first place?</p>\n<p>The answer is simple: Because our input data is one-dimensional. Wait! Didn’t we just say we setup <code class=\"language-text\">training_data</code> as a two-dimensional array? Yes, that’s right. It’s an array of arrays but only because it’s an array holding different samples to feed into our network. Each sample though is one-dimensional. That is what counts for when we have to pick between different types of layers. Consider each sample would be an array or arrays instead.</p>\n<p>`<code class=\"language-text\"></code>py`\nother<em>training</em>data = np.array([[[0,0],\n[0,0]],\n[[1,0],\n[0,1]]\n[[0,1],\n[1,0]],\n[[1,1],\n[1,1]]], “float32”)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">If that was the case we&#39;d have to pick a different layer because a `Dense` layer is really only for one-dimensional input. We&#39;ll get to the more advanced use cases with two-dimensional input data in another blog post soon.\n\nNow that we know we have to pick a `Dense` layer, how do we find the right configuration? We&#39;ve already learned why we set the `input_dim` to `2` and that setting the output dimension to `16` means spreading into 16 neurons in a so called hidden layer. But why 16?\n\nThe answer may surprise you but it&#39;s simply a question of measuring the performance of our model and tweaking the size of the model accordingly. Remember that this number affects the number of weights that exists in our model. More weights mean more room for the model to care for certain features in the data we feed to it.\n\n&gt; **Special Tip:** As a rule of thumb the model should be big enough to deal with the task but not bigger. If the model is too big it may start finding pattern in your data that are actually irrelevant for the problem at hand. Keeping the model at a reasonable size means it&#39;s forced to look at the relevant pattern.\n\n\n## Measure and tweak\n\nLet&#39;s run our code and take a look at the output. If you aren&#39;t sure how to run it please revisit out [previous post](/machine-learning/2016/09/23/beginning-ml-with-keras-and-tensorflow.html). Alternatively jump to the end of this section to find the interactive embedded lab or [open it on MachineLabs](https://machinelabs.ai/editor/Hya9gmXvb/1501929813281-ByTLbXXDZ?file=main.py) directly.\n\n```sh\nEpoch 1/20000\n0s - loss: 0.7443 - binary_accuracy: 0.2500\nEpoch 2/20000\n0s - loss: 0.7428 - binary_accuracy: 0.2500\n...\nEpoch 62/20000\n0s - loss: 0.6881 - binary_accuracy: 0.2500\nEpoch 63/20000\n0s - loss: 0.6876 - binary_accuracy: 0.5000\n...\n0s - loss: 0.6801 - binary_accuracy: 0.5000\nEpoch 81/20000\n0s - loss: 0.6797 - binary_accuracy: 0.7500\n...\nEpoch 283/20000\n0s - loss: 0.5948 - binary_accuracy: 0.7500\nEpoch 284/20000\n0s - loss: 0.5943 - binary_accuracy: 1.0000</code></pre></div>\n<p>Since we’ve set <code class=\"language-text\">verbose=2</code> and <code class=\"language-text\">metrics=[&#39;binary_accuracy&#39;]</code> earlier we get all these nice infos after each epoch. The interesting number we want to focus on is <code class=\"language-text\">binary_accuracy</code>. Guess what the <code class=\"language-text\">0.2500</code> at the first two epochs mean? If you’re thinking it means that our model predicts one out of our four states correctly you’re damn right. It took us 63 epochs to predict half of the four states correctly. After 284 epochs the model makes perfect predictions for all of our four XOR states.</p>\n<p>Now we can start making changes to our model and see how it affects the performance. Let’s try to increase the size of our hidden layer from 16 to 32.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">0s - loss: 0.6023 - binary_accuracy: 0.7500\nEpoch 124/20000\n0s - loss: 0.6015 - binary_accuracy: 1.0000</code></pre></div>\n<p>Now, that’s cool! Took us only 124 epochs to get to an accuracy of 100%!</p>\n<p>What if we stack in another layer?</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> input_dim<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'relu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'relu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'sigmoid'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Interesting. That change brings us down to 56 epochs to solve the task. But would that be the same as just using one hidden layer with a size of 64?</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">64</span><span class=\"token punctuation\">,</span> input_dim<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'relu'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'sigmoid'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Turns out, it isn’t. With this configuration our model starts making perfect predictions after 32 epochs.</p>\n<p>Notice how we are able to play and figure out lots of interesting details once we start looking at the right metrics?</p>\n<h2>Solving XOR with no activation function at all.</h2>\n<p>Let’s see if we can hold our claim of solving XOR without any activation function at all. We change our model to look like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">model <span class=\"token operator\">=</span> Sequential<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">128</span><span class=\"token punctuation\">,</span> input_dim<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'linear'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nmodel<span class=\"token punctuation\">.</span>add<span class=\"token punctuation\">(</span>Dense<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> activation<span class=\"token operator\">=</span><span class=\"token string\">'linear'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Wait? But this says we actually do use an activation function called <code class=\"language-text\">linear</code>! What’s going on here?</p>\n<p>If we look at the keras source code we’ll see it is defined as <a href=\"https://github.com/fchollet/keras/blob/25dbe8097fba9a6a429e19d0625d78c3b8731527/keras/activations.py#L45-L49\">this</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">def</span> <span class=\"token function\">linear</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">'''\n    The function returns the variable that is passed in, so all types work.\n    '''</span>\n    <span class=\"token keyword\">return</span> x</code></pre></div>\n<p>The function simply returns it’s input without applying any math, so it’s essentially the same as using no activation function at all.</p>\n<p>Honestly, this is just a little fun experiment but if we increase the number of epochs we can see that even with this config we can build up a net to make 100 % correct predictions.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">Epoch <span class=\"token number\">3718</span><span class=\"token operator\">/</span><span class=\"token number\">20000</span>\n0s <span class=\"token operator\">-</span> loss<span class=\"token punctuation\">:</span> <span class=\"token number\">0.2500</span> <span class=\"token operator\">-</span> binary_accuracy<span class=\"token punctuation\">:</span> <span class=\"token number\">1.0000</span></code></pre></div>\n<p>You can play with all these different configurations and see there effect from right within this embedded lab.</p>\n<iframe height=\"400\" scrolling=\"no\" title=\"MNIST in the browser\" src=\"https://machinelabs.ai/embedded/Hya9gmXvb/1501929813281-ByTLbXXDZ?file=main.py\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">\n      See the Lab <a href=\"https://machinelabs.ai/editor/Hya9gmXvb/1501929813281-ByTLbXXDZ?file=main.py\">Understanding XOR with Keras</a> on <a href=\"https://machinelabs.ai\">MachineLabs</a>.\n</iframe>\n<h2>Conclusion</h2>\n<p>Whew! If you made it this far we’ll have to say THANK YOU for bearing so long with us just for the sake of understanding a model to solve XOR. If there’s just one take away we hope it’s that we don’t have to be a mathematician to start with machine learning.</p>\n<p>Once we understood some basics and learn how to measure the performance of our network we can figure out a lot of exciting things through trial and error.</p>","frontmatter":{"author":"christoph_burgdorf","title":"Understanding XOR with Keras and TensorFlow","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAgP/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABnsbfSAdiv//EABgQAAMBAQAAAAAAAAAAAAAAAAABAgMh/9oACAEBAAEFApUs0Q2jGUjTs1Hf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAACH/2gAIAQIBAT8BiP/EABoQAQACAwEAAAAAAAAAAAAAAAAhUQEREjH/2gAIAQEABj8CpjqnjaUP/8QAGxABAAMBAAMAAAAAAAAAAAAAAQARMSFBUWH/2gAIAQEAAT8h9yoNdjwo2BeOZi37CEDSBtRP/9oADAMBAAIAAwAAABD/AC//xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QVKz/xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8Qbog//8QAHBABAQACAgMAAAAAAAAAAAAAAREAITFhUZHR/9oACAEBAAE/EJvd4o+sqkIAJR9xySd6zbIi3BLEpvBKvgd5/9k=","aspectRatio":1.4985014985014986,"src":"/static/1c152033d2fc4647b9ec172d59747070/30037/understanding-xor-with-keras-and-tensorflow.jpg","srcSet":"/static/1c152033d2fc4647b9ec172d59747070/10bdc/understanding-xor-with-keras-and-tensorflow.jpg 158w,\n/static/1c152033d2fc4647b9ec172d59747070/f4ab0/understanding-xor-with-keras-and-tensorflow.jpg 315w,\n/static/1c152033d2fc4647b9ec172d59747070/30037/understanding-xor-with-keras-and-tensorflow.jpg 630w,\n/static/1c152033d2fc4647b9ec172d59747070/9810d/understanding-xor-with-keras-and-tensorflow.jpg 945w,\n/static/1c152033d2fc4647b9ec172d59747070/ff2e4/understanding-xor-with-keras-and-tensorflow.jpg 1260w,\n/static/1c152033d2fc4647b9ec172d59747070/2a5e2/understanding-xor-with-keras-and-tensorflow.jpg 1500w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"02 November 2016","summary":"In this article we'll take a closer look at a simple model for a neural net to solve an XOR gate. Even with such a basic task, we can figure out quite a bunch of interesting things.","categories":["machine-learning"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/machine-learning/2016/11/02/understanding-XOR-with-keras-and-tensorlow.html","previous":{"fields":{"slug":"/announcements/2016/10/30/announcing-angular-2-master-class-in-sydney.html"},"frontmatter":{"date":"2016/10/30","title":"Announcing Angular 2 Master Class in Sydney","categories":["announcements"]}},"next":{"fields":{"slug":"/angular/2016/11/28/testing-services-with-http-in-angular-2.html"},"frontmatter":{"date":"2016/11/28","title":"Testing Services with Http in Angular","categories":["angular"]}}}}}
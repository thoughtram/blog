{"componentChunkName":"component---src-templates-blog-post-js","path":"/angular/2016/09/14/bypassing-providers-in-angular-2.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"ac31b74c-f08c-58c5-8381-0394b6bfe725","excerpt":"We covered a lot of different things regarding dependency injection in Angular. However, at our latest training, one of our students came up with a very…","html":"<p>We covered a lot of different things regarding dependency injection in Angular. However, at our latest training, one of our students came up with a very interesting question: </p>\n<blockquote>\n<blockquote>\n<p>“Can I bypass a provider to get a dependency from another ancestor provider?”</p>\n</blockquote>\n</blockquote>\n<p>This was then followed by a very interesting, collaborative discussion with the other students, as we all tried to come up with a solution - and it turned out, there <strong>is</strong> a solution. In this article we’d like to quickly demonstrate the problem and then show how we can use one of Angular’s provider recipes to solve it in a very elegant way.</p>\n<h2>Understanding the Problem</h2>\n<p>As discussed in other <a href=\"/angular/2015/05/18/dependency-injection-in-angular-2.html\">articles</a>, dependencies in Angular are singletons inside their injector containers they belong to. If we need multiple dependency instances, we can take advantage of the injector tree, and provide different instances via different providers.</p>\n<p>To illustrate what that means, let’s take a look at the following figure:</p>\n<p><img src=\"/bca1a6fa015ccd5fca4e829987f67fa7/injector-tree.svg\"></p>\n<p>What we see here is a tree of components, which is usually what an application in Angular is composed of. We also see that every component comes with its own injector. This allows us to configure how and what is going to be created when we ask for dependencies, on a component level.</p>\n<p>Let’s say we have an application where we use a <code class=\"language-text\">DataService</code> to perform actions like fetching data, adding data and deleting data. To make this service injectable,  we need to create a provider for it first.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DataService</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// this is usually imported from somewhere</span>\n\n@<span class=\"token function\">NgModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>DataService<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppModule</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once we created the provider, we can ask for dependencies of that type in our components like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> contactService<span class=\"token punctuation\">:</span> DataService</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In fact, all components in our component tree will now get exactly the same instance, because their injectors will keep looking upwards in the tree for a provider, until they find one.</p>\n<p><img src=\"/2dd8e9b119adc196261798a139c683ab/injector-tree-2.svg\"></p>\n<p>We can get a different instance of the same service by adding another provider with the same configuration to the injector tree. Providers can be defined on components as well, to configure the corresponding injector.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>DataService<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeOtherComponent</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>This will affect the dependency lookup in the sense that all children components and the <code class=\"language-text\">SomeOtherComponent</code> component itself will get the <code class=\"language-text\">DataService</code> instance from <code class=\"language-text\">SomeOtherComponent</code>’s injector, instead of the one configured in the <code class=\"language-text\">NgModule</code>.</p>\n<p><img src=\"/7cd38f19f51a597d970346585e57a9c6/injector-tree-3.svg\"></p>\n<p>As we can see, all components in the left part of the tree get their dependency instance from a different provider than the components in the right part of the tree. Okay cool, nothing new here, this has all been discussed in our guide on <a href=\"/angular/2015/05/18/dependency-injection-in-angular-2.html\">DI in Angular</a>.</p>\n<p>However, now we have a problem. What if we <strong>want</strong> to get a dependency instance of the root provider (or just another ancestor), essentially bypassing the nearest provider, even though our component is in the left part of the tree? To illustrate the problem, here another figure:</p>\n<p><img src=\"/b85647d61ad1b8e9ac1b77890f04b18a/injector-tree-4.svg\"></p>\n<p>With the current setup, both providers use the exact same token, so there’s no way for us we can distinguish between the two different dependency instances.</p>\n<p>Luckily, Angular comes with a couple more provider strategies (<code class=\"language-text\">useValue</code>, <code class=\"language-text\">useFactory</code>, …), that define how dependencies are created. One of them is <code class=\"language-text\">useExisting</code>, and we’ll now take a look at how it solves our problem.</p>\n<h2>Creating alias tokens with <code class=\"language-text\">useExisting</code></h2>\n<p><code class=\"language-text\">useExisting</code> is a bit different than the other provider strategies. It’s the only strategy that doesn’t actually create an instance, but instead, <strong>it points to another token</strong> which in turn will create the instance.</p>\n<p>To give an example, let’s say we want to be able to not only use the <code class=\"language-text\">DataService</code> type as a token to ask for the dependency, but also the token <code class=\"language-text\">RootDataService</code>. We can easily do that with the following provider configuration (as always, we can do the same in <code class=\"language-text\">@Component</code> decorators):</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DataService</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// this is usually imported from somewhere</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">RootDataService</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// alias token, also usually imported from somewhere</span>\n\n@<span class=\"token function\">NgModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    DataService<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> RootDataService<span class=\"token punctuation\">,</span> useExisting<span class=\"token punctuation\">:</span> DataService <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppModule</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>What this does is, it tells Angular when someone asks for a dependency for the token <code class=\"language-text\">RootDataService</code>, inject the dependency instance that is created for the token <code class=\"language-text\">DataService</code>. Or in other words, we just created an alias that gives us the exact same instance that we get for the <code class=\"language-text\">DataService</code> token.</p>\n<p>We can then go ahead and use the alias token to inject our service instance just like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeComponent</span> <span class=\"token punctuation\">{</span>\n  \n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> contactService<span class=\"token punctuation\">:</span> RootDataService</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again, this is the exact same instance. Now, why is this helpful? Well… now that we have two different tokens to get the same instance, it’s no longer a problem that another provider in the injector tree “shadows” the provider from our root injector. We can now ask for the dependency instance of <code class=\"language-text\">DataService</code> that is created at the very top of our tree, no matter where we are in the component tree, because the alias token still points to the original instance.</p>\n<p>One more thing we could do is to get rid off the class definition <code class=\"language-text\">RootDataService</code>. We only created it so we can use it as a token, other than that, there’s no use for it. Luckily, we can also use strings to create tokens, or even better, <a href=\"/angular/2016/05/23/opaque-tokens-in-angular-2.html\">we use OpaqueTokens</a>.</p>\n<p>To see things in action, check out the demos below!</p>","frontmatter":{"author":"pascal_precht","title":"Bypassing Providers in Angular","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQCAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAFK5ODLxlgX/8QAGhABAQACAwAAAAAAAAAAAAAAAQACAxIUIf/aAAgBAQABBQI2RsA7TZZcZfL/xAAWEQEBAQAAAAAAAAAAAAAAAAAAARL/2gAIAQMBAT8Bar//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAdEAABAgcAAAAAAAAAAAAAAAAAAQIQESEyM5Gh/9oACAEBAAY/ArSremNNko//xAAXEAEBAQEAAAAAAAAAAAAAAAABABEh/9oACAEBAAE/ITcxMgREgfIbONJU7bf/2gAMAwEAAgADAAAAEJT/AP/EABURAQEAAAAAAAAAAAAAAAAAABBh/9oACAEDAQE/EKH/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQIBAT8QqY//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMXFhkbH/2gAIAQEAAT8QIoztFlQjrqdSOm4BQo2EIhQGSvI7FOgMCcrO5//Z","aspectRatio":1.4992503748125936,"src":"/static/b43e9d933d58ce9d3708a478326fccbe/30037/bypassing-providers-in-angular-2.jpg","srcSet":"/static/b43e9d933d58ce9d3708a478326fccbe/10bdc/bypassing-providers-in-angular-2.jpg 158w,\n/static/b43e9d933d58ce9d3708a478326fccbe/f4ab0/bypassing-providers-in-angular-2.jpg 315w,\n/static/b43e9d933d58ce9d3708a478326fccbe/30037/bypassing-providers-in-angular-2.jpg 630w,\n/static/b43e9d933d58ce9d3708a478326fccbe/9810d/bypassing-providers-in-angular-2.jpg 945w,\n/static/b43e9d933d58ce9d3708a478326fccbe/ff2e4/bypassing-providers-in-angular-2.jpg 1260w,\n/static/b43e9d933d58ce9d3708a478326fccbe/883ab/bypassing-providers-in-angular-2.jpg 2000w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"14 September 2016","summary":"Dependencies are provided from the nearest ancestor provider in the injector tree. This article shows how to bypass it.","categories":["angular"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angular/2016/09/14/bypassing-providers-in-angular-2.html","previous":{"fields":{"slug":"/announcements/2016/08/30/announcing-angular-2-master-class-in-nyc.html"},"frontmatter":{"date":"2016/08/30","title":"Announcing Angular 2 Master Class in NYC","categories":["announcements"]}},"next":{"fields":{"slug":"/angular/2016/09/15/angular-2-final-is-out.html"},"frontmatter":{"date":"2016/09/15","title":"Angular 2 is out - Get started here","categories":["angular"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/angular/2016/05/23/opaque-tokens-in-angular-2.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"307b0b4a-692b-5521-af8d-ae1f4dc7021d","excerpt":"If you’ve read our article series on everything dependency injection in Angular, you’ve probably realized that Angular is doing a pretty good job on that. We…","html":"<p>If you’ve read our article series on everything dependency injection in Angular, you’ve probably realized that Angular is doing a pretty good job on that. We can either use string or type tokens to make dependencies available to the injector. However, when using string tokens, there’s a possibility of running into naming collisions because… well, maybe someone else has used the same token for a different provider. In this article, we’re going to learn how so-called “opaque tokens” solve this problem.</p>\n<p><strong>UPDATE</strong>: Since Angular version 4.x <code class=\"language-text\">OpaqueToken</code> is considered deprecated in favour of <code class=\"language-text\">InjectionToken</code>. Learn about the differences <a href=\"#injectiontoken-since-angular-4x\">here</a>.</p>\n<p>Before we jump into the actual problem we want to solve, let’s first recap the differences between a string token and a type token.</p>\n<h2>String Tokens vs Type Tokens</h2>\n<p>Angular DI injects singleton instances which are created by provider-registered factories. And it is these instances that are injected at runtime. In order to configure your application DI and associate a factory with a token, we have to setup providers. A couple weeks ago we blogged how <a href=\"/angular/2016/05/13/angular-2-providers-using-map-literals.html\">providers can be created using Map literals</a>, if you haven’t read this one yet we recommend to check it out, as this article pretty much builds up on that one.</p>\n<p>The bottom line is that a provider token can be either a string or a type. Depending on our use case, we want to use one or the other. For example, if we have a <code class=\"language-text\">DataService</code> class, and all we want to do is inject an instance of that class when we ask for a dependency of that type, we would use <code class=\"language-text\">DataService</code> as a provider token like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  selector<span class=\"token punctuation\">:</span> <span class=\"token string\">'my-component'</span><span class=\"token punctuation\">,</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>provide<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> dataService<span class=\"token punctuation\">:</span> DataService</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Since the token matches the dependency instance-type and the provider strategy is <code class=\"language-text\">useClass</code>, we can also use the <strong>shorthand</strong> version, as:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>DataService<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Angular has many shorthand versions (DI, annotations, etc); and the above code is just one example of those.</p>\n<p>Now this is cool, as long as we have classes (or types) to represent the things we want to work with. However, sometimes we need to create other objects that don’t necessarily need to be put in a class representation. We could, for example, have a configuration object that we want to inject into our application. This configuration object can be a simple object literal where there is no type involved.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">CONFIG</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  apiUrl<span class=\"token punctuation\">:</span> <span class=\"token string\">'http://my.api.com'</span><span class=\"token punctuation\">,</span>\n  theme<span class=\"token punctuation\">:</span> <span class=\"token string\">'suicid-squad'</span><span class=\"token punctuation\">,</span>\n  title<span class=\"token punctuation\">:</span> <span class=\"token string\">'My awesome app'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Or maybe, we have a primitive value we want to make injectable, like a string or a boolean value.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">FEATURE_ENABLED</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In these cases, we can’t use the <code class=\"language-text\">String</code> or <code class=\"language-text\">Boolean</code> type, as this would set a default value for the place where we ask for dependencies of these types. And we really don’t want to introduce a new type just to represent these values.</p>\n<p>That’s where string tokens come into play. They allow us to make objects available via DI without introducing an actual type:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> featureEnabledToken <span class=\"token operator\">=</span> <span class=\"token string\">'featureEnabled'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> configToken <span class=\"token operator\">=</span> <span class=\"token string\">'config'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">...</span>\nproviders<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> featureEnabledToken<span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">FEATURE_ENABLED</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> configToken<span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">CONFIG</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Basically all we do is, instead of using a type, we use a simple string as a token. We can inject this dependency using the <code class=\"language-text\">@Inject()</code> decorator likes this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> Inject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">@<span class=\"token function\">Inject</span><span class=\"token punctuation\">(</span>featureEnabledToken<span class=\"token punctuation\">)</span> <span class=\"token keyword\">private</span> featureEnabled<span class=\"token punctuation\">,</span>\n    @<span class=\"token function\">Inject</span><span class=\"token punctuation\">(</span>configToken<span class=\"token punctuation\">)</span> <span class=\"token keyword\">private</span> config</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Note: that above we used <code class=\"language-text\">@Inject(featureEnabledToken) private featureEnabled</code> without any typing information; e.g. <code class=\"language-text\">private featureEnabled:boolean</code>.</p>\n<p>Okay awesome, we can use strings and types as tokens to inject dependencies in our application. Unfortunately, using string tokens like this opens up potential risks for naming collisions.</p>\n<h2>The problem with string tokens</h2>\n<p>Let’s get back to our <code class=\"language-text\">config</code> string token for a second. “config” is a pretty general name, so we probably could’ve done better naming this thing in the first place. However, even if we come up with a more distinguishable name, it is easily possible that someone else will use the same string as a token. Providers are flattened, meaning that, if there are multiple providers with the same token, the last one wins.</p>\n<p>And there is another concept that allows us to define multiple providers for the same token. Those are multi providers, and we’ve written about them <a href=\"/angular2/2015/11/23/multi-providers-in-angular-2.html\">here</a>.</p>\n<p>Let’s say we use some sort of third-party library that comes with a set of providers defined like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token constant\">THIRD_PARTY_LIB_PROVIDERS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> <span class=\"token string\">'config'</span><span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> ThirdParyConfig <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Even though it’s not a common pattern to use a string token with a class, it’s totally possible to do that, but we really just want to demonstrate the problem here. We can import and use these third-party providers like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token constant\">THIRD_PARTY_LIB_PROVIDERS</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./third-party-lib'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">...</span>\nproviders <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  DataService<span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">THIRD_PARTY_LIB_PROVIDERS</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Okay, so far so good. Very often, we don’t really know what’s defined behind other library providers unless we check out the documentation or the source code. Let’s assume we also don’t know this time, that there’s a string token for <code class=\"language-text\">config</code>, and we try to add our own provider like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">...</span>\nproviders <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  DataService<span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">THIRD_PARTY_LIB_PROVIDERS</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> configToken<span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">CONFIG</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>This will pretty much break our third-party library, because now, the thing that gets injected for the <code class=\"language-text\">config</code> string token is a different object than what the library expects. We basically ran into a naming collision.</p>\n<h2>Opaque Tokens to the rescue</h2>\n<p>Luckily, Angular anticipated such scenarios. It comes with a type called <code class=\"language-text\">OpaqueToken</code> that basically allows us to create string-based tokens without running into any collisions.</p>\n<p>Creating an <code class=\"language-text\">OpaqueToken</code> is easy. All we need to do is to import and use it. Here’s what the third-party providers collection looks like using <code class=\"language-text\">OpaqueToken</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> OpaqueToken <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">CONFIG_TOKEN</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'config'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> <span class=\"token constant\">THIRDPARTYLIBPROVIDERS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> <span class=\"token constant\">CONFIG_TOKEN</span><span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> ThirdPartyConfig <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Of course, this is an implementation detail and we usually shouldn’t have to care about what APIs are used inside a third-party library. Let’s assume we’ve created an <code class=\"language-text\">OpaqueToken</code> for our config token as well.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> OpaqueToken <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token constant\">THIRDPARTYLIBPROVIDERS</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./third-party-lib'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">MY_CONFIG_TOKEN</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'config'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token operator\">...</span>\nproviders <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n  DataService<span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">THIRDPARTYLIBPROVIDERS</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> <span class=\"token constant\">MY_CONFIG_TOKEN</span><span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token constant\">CONFIG</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Running this code will show us that, even though our application seems to use the exact same string token for different providers, Angular’s DI is still smart enough to figure out which dependency we’re interested in. As if we’d have two <em>different</em> tokens. And technically, this is exactly what happens.</p>\n<h2>Why it works</h2>\n<p>If we take a look at the implementation of <code class=\"language-text\">OpaqueToken</code> we’ll realize that it’s just a simple class with only a <code class=\"language-text\">.toString()</code> method.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OpaqueToken</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">private</span> _desc<span class=\"token punctuation\">:</span> string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> string <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Token </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_desc<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">toString()</code> gets called when an error is thrown in case we’re asking for a dependency that doesn’t have a provider. All it does is add a tiny bit more information to the error message.</p>\n<p>However, the secret sauce is, that we’re creating actual object instances of <code class=\"language-text\">OpaqueToken</code> as opposed to simple string primitives. That’s why Angular’s DI is able to distinguish between our opaque tokens, even though they are based on the same string, because these instances are never the same.</p>\n<p>We can easily double-check the equality of two opaque tokens like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">TOKEN_A</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'token'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">TOKEN_B</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'token'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token constant\">TOKEN_A</span> <span class=\"token operator\">===</span> <span class=\"token constant\">TOKEN_B</span> <span class=\"token comment\">// false</span></code></pre></div>\n<h2>InjectionToken since Angular 4.x</h2>\n<p>Since Angular version 4.x there’s a new, even a little bit better, way of achieving this. <code class=\"language-text\">InjectionToken</code> does pretty much the same thing as <code class=\"language-text\">OpaqueToken</code> (in fact, it derives from it). However, it allows to attach type info on the token via TypeScript generics, plus, it adds a little bit of sugar that makes the developer’s life a bit more pleasant when creating factory providers that come with their own dependencies.</p>\n<p>Let’s take a look at the following provider configuration for <code class=\"language-text\">DataService</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">API_URL</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'apiUrl'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\nproviders<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    provide<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">useFactory</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">http<span class=\"token punctuation\">,</span> apiUrl</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// create data service</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    deps<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      Http<span class=\"token punctuation\">,</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Inject</span><span class=\"token punctuation\">(</span><span class=\"token constant\">API_URL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>We’re using a factory function that will create a <code class=\"language-text\">DataService</code> instance using <code class=\"language-text\">http</code> and <code class=\"language-text\">apiUrl</code>. To ensure Angular knows what <code class=\"language-text\">http</code> and <code class=\"language-text\">apiUrl</code> are, we add the corresponding DI token to the provider configuration’s <code class=\"language-text\">deps</code> property. Notice how we can just add the <code class=\"language-text\">Http</code> token. However, <code class=\"language-text\">apiUrl</code> is providing using an <code class=\"language-text\">OpaqueToken</code>, and since it since a type, we have to use the <code class=\"language-text\">Inject()</code> constructor (equivalent of <code class=\"language-text\">@Inject()</code> inside constructors).</p>\n<p>While this works perfectly fine, developers often ran into errors when they forgot to call <code class=\"language-text\">new Inject()</code> on the token. <strong>That’s why since Angular 4.x we don’t have to do this anymore.</strong> We can replace all <code class=\"language-text\">OpaqueToken</code> instances with <code class=\"language-text\">InjectionToken</code> instances and everything would work exactly the same way, except for the fact that we don’t have to call <code class=\"language-text\">new Inject()</code> in factory provider dependencies anymore. Also, notice the generic. It’s the type of what the injector is going to return.</p>\n<p>In other words, the code above can then be written like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">API_URL</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InjectionToken</span><span class=\"token operator\">&lt;</span>string<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token string\">'apiUrl'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// generic defines return value of injector</span>\n\n\nproviders<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    provide<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">useFactory</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">http<span class=\"token punctuation\">,</span> apiUrl</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// create data service</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    deps<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      Http<span class=\"token punctuation\">,</span>\n      <span class=\"token constant\">API_URL</span> <span class=\"token comment\">// no `new Inject()` needed!</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>Cool right? As of version 4.x <code class=\"language-text\">OpaqueToken</code> is considered deprecated.</p>\n<h2>Conclusion</h2>\n<p>Opaque tokens are distinguishable and prevent us from running into naming collisions. In addition, they provide a bit better error messages. Whenever we create a token that is not a type, <code class=\"language-text\">OpaqueToken</code> should be used. If we’re using Angular in version >= 4.x, we use <code class=\"language-text\">InjectionToken</code> instead.</p>","frontmatter":{"author":"pascal_precht","title":"How to prevent name collisions in Angular providers","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB5d0JkI//xAAbEAACAQUAAAAAAAAAAAAAAAAAAQIDERITQf/aAAgBAQABBQJWblTaMWazp//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/AYf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGn/8QAFxAAAwEAAAAAAAAAAAAAAAAAABARMf/aAAgBAQAGPwKPSVf/xAAaEAADAQADAAAAAAAAAAAAAAAAARExIUFR/9oACAEBAAE/IYASlMRwj7ODuz0t0//aAAwDAQACAAMAAAAQVz//xAAXEQEBAQEAAAAAAAAAAAAAAAABACEx/9oACAEDAQE/EFHbL//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EAM//8QAHBABAQEAAgMBAAAAAAAAAAAAAREAMWEhQXHR/9oACAEBAAE/EIRVWDNQMxY0PpkAFfS6fzF8fKbyzERHnrf/2Q==","aspectRatio":1.5,"src":"/static/a84e9cd7a44e1552f05a87d6222f53e6/30037/opaque-tokens-in-angular-2.jpg","srcSet":"/static/a84e9cd7a44e1552f05a87d6222f53e6/10bdc/opaque-tokens-in-angular-2.jpg 158w,\n/static/a84e9cd7a44e1552f05a87d6222f53e6/f4ab0/opaque-tokens-in-angular-2.jpg 315w,\n/static/a84e9cd7a44e1552f05a87d6222f53e6/30037/opaque-tokens-in-angular-2.jpg 630w,\n/static/a84e9cd7a44e1552f05a87d6222f53e6/9810d/opaque-tokens-in-angular-2.jpg 945w,\n/static/a84e9cd7a44e1552f05a87d6222f53e6/ff2e4/opaque-tokens-in-angular-2.jpg 1260w,\n/static/a84e9cd7a44e1552f05a87d6222f53e6/2a5e2/opaque-tokens-in-angular-2.jpg 1500w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"23 May 2016","summary":"Angular provides a mechanism to avoid name collisions in provider tokens. In this article we're going to explore how opaque tokens make this possible.","categories":["angular"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angular/2016/05/23/opaque-tokens-in-angular-2.html","previous":{"fields":{"slug":"/announcements/2016/05/19/thomas-joins-thoughtram.html"},"frontmatter":{"date":"2016/05/19","title":"Thomas joins thoughtram","categories":["announcements"]}},"next":{"fields":{"slug":"/angular/2016/06/08/component-relative-paths-in-angular-2.html"},"frontmatter":{"date":"2016/06/08","title":"Component-Relative Paths in Angular","categories":["angular"]}}}}}
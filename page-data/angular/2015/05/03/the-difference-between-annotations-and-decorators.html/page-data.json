{"componentChunkName":"component---src-templates-blog-post-js","path":"/angular/2015/05/03/the-difference-between-annotations-and-decorators.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"b214c29f-2420-5d13-afee-13108650b45b","excerpt":"Last year, the Angular team announced it’s ECMAScript language extension AtScript, which adds types and annotations to the language in order to enable better…","html":"<p>Last year, the Angular team announced it’s ECMAScript language extension AtScript, which adds types and annotations to the language in order to enable better tooling, debugging and overall development experience. Half a year later at ng-conf, the team announced that AtScript becomes TypeScript, which supports annotations and another feature called “decorators”.</p>\n<p>But how do those annotations actually work? And what are decorators then? This article details the translation of annotations and how they differ from decorators.</p>\n<h2>Annotations</h2>\n<p>Let’s start off with annotations. As mentioned, the Angular team announced AtScript  as their language extension to JavaScript. AtScript comes with features like <strong>Type Annotations</strong>, <strong>Field Annotations</strong> and <strong>MetaData Annotations</strong>. We’re going to focus on metadata annotations. Let’s take a look at the following Angular component to get an idea of what metadata annotations can look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  selector<span class=\"token punctuation\">:</span> <span class=\"token string\">'tabs'</span><span class=\"token punctuation\">,</span>\n  template<span class=\"token punctuation\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    &lt;ul>\n      &lt;li>Tab 1&lt;/li>\n      &lt;li>Tab 2&lt;/li>\n    &lt;/ul>\n  </span><span class=\"token template-punctuation string\">`</span></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Tabs</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We have a class <code class=\"language-text\">Tabs</code> that is basically empty. The class has one annotation <code class=\"language-text\">@Component</code>. If we’d remove all annotations, what would be left is just an empty class that doesn’t have any special meaning right? So it seems that <code class=\"language-text\">@Component</code> add some metadata to the class in order to give it a specific meaning. This is what annotations are all about. They are a declarative way to add metadata to code.</p>\n<p><code class=\"language-text\">@Component</code> is an annotation that tells Angular, that the class, which the annotation is attached to, is a component.</p>\n<p>Okay, even if that seems to be quite clear, there are a few questions coming up:</p>\n<ul>\n<li>Where do those annotations come from? This is nothing that JavaScript gives us out of the box right?</li>\n<li>Who defined this annotations called <code class=\"language-text\">@Component</code>?</li>\n<li>If this is part of AtScript, what does that translate to, so we can use it in today’s browsers?</li>\n</ul>\n<p> Let’s answer these one by one. Where do those annotations come from? To answer that question, we need to complete the code sample. <code class=\"language-text\">@Component</code> is something we need to import from the Angular framework like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> \n  ComponentMetadata <span class=\"token keyword\">as</span> Component<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This pretty much answers our first question. Both annotations are provided by the framework. Let’s take a look at what the implementation of those annotations look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ComponentMetadata</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">DirectiveMetadata</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can see that <code class=\"language-text\">ComponentMetadata</code> is in fact an implementation detail of the Angular framework. This answers our second question.</p>\n<p>But wait. It’s just yet another class? How can just a simple class change the way how other classes behave? And why are we able to use those classes as annotations by just prefixing them with an <code class=\"language-text\">@</code> sign? Well, actually we can’t. Annotations are not available in browser’s of today, which means we need to transpile it to something that <em>does</em> run in current browsers.</p>\n<p>Even though we have a couple of transpilers we can choose from. Babel, Traceur, TypeScript, … It turns out there’s only one that actually implements annotations as we know them from AtScript: Traceur. Taking the component code from above, this is what it translates to using Traceur:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> Tabs <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">Tabs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  Tabs<span class=\"token punctuation\">.</span>annotations <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">ComponentMetadata</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> Tabs<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>In the end, a class is just a function, which is also just an object, and all annotations end up as instance calls on the <code class=\"language-text\">annotations</code> property of the class. When I said “all” annotations end up there, I actually lied a bit. We can have parameter annotations as well and whose will be assigned to a class’ <code class=\"language-text\">parameters</code> property. So if we have code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">@<span class=\"token function\">Annotation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> foo</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This would translate to something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> MyClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n  MyClass<span class=\"token punctuation\">.</span>parameters <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Annotation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> MyClass<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The reason why this translate to a nested array, is because a parameter can have more than one annotation.</p>\n<p>Okay, so now we know what those metadata annotations are and what they translate to, but we still don’t know how something like <code class=\"language-text\">@Component</code> makes a normal class actually a component in Angular. It turns out that Angular itself takes care of that. Annotations are really just metadata added to code. That’s why <code class=\"language-text\">@Component</code> is a very specific implementation detail of Angular. In fact, there are a couple of other annotations that the framework comes with. But also only the framework knows what to do with that information.</p>\n<p>Another very interesting learning is that Angular expects the metadata on <code class=\"language-text\">annotations</code> and <code class=\"language-text\">parameters</code> properties of classes. If Traceur would not translate them to those particular properties, Angular wouldn’t know from where to get the metadata. Which makes <strong>AtScript Annotations</strong> just a very specific implementation of what annotations could actually be.</p>\n<p>Wouldn’t it be nicer if you as a consumer could decide where your metadata is attached to in your code? Yes! And this is where decorators come into play.</p>\n<h2>Decorators</h2>\n<p>Decorators are a <a href=\"https://github.com/wycats/javascript-decorators\">proposed standard</a> for ECMAScript 2016 by Yehuda Katz, to annotate and modify classes and properties at design time. This sounds pretty much like what annotations do right? Well… sort of. Let’s take a look at what a decorator looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// A simple decorator</span>\n@decoratorExpression\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Wait. This looks exactly like an AtScript annotation! That’s right. But it isn’t. From a consumer perspective, a decorator indeed looks like the thing that we know as “AtScript Annotation”. There is a significant difference though. <strong>We</strong> are in charge of what our decorator does to our code. Taking the code above, a corresponding decorator implementation for <code class=\"language-text\">@decoratorExpression</code> could look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">decoratorExpression</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">target</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\">// Add a property on target</span>\n   target<span class=\"token punctuation\">.</span>annotated <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Right. A decorator is just a function that gives you access to the <code class=\"language-text\">target</code> that needs to be decorated. Get the idea? Instead of having a transpiler that decides where your annotations go, we are in charge of defining what a specific decoration/annotation does.</p>\n<p>This, of course, also enables us to implement a decorator that adds metadata to our code the same way AtScript annotations do (I keep referring to “AtScript annotations” because what they do, is really an AtScript specific thing). Or in other words: with decorators, we can build annotations.</p>\n<p>There’s a lot more to explore about decorators, but that is out of the scope of this article. I recommend checking out <a href=\"https://github.com/wycats/javascript-decorators\">Yehuda’s proposal</a> to learn more about the feature.</p>\n<h2>Does TypeScript support Annotations or Decorators?</h2>\n<p>As you might know, the Angular team announced earlier this year that they’re going to drop the term “AtScript” in favour of TypeScript, since both languages seem to solve the same problems. In addition, there were announcements that TypeScript will support annotations <strong>and</strong> decorators once version 1.5 alpha is out.</p>\n<p>It turns out that it actually doesn’t. TypeScript supports decorators, but doesn’t know about Angular specific annotations. Which makes sense, because they are an implementation detail of Angular. That also means that either we as consumers, or the framework needs to provide those decorators in order to make the code compile. Only the latter really makes sense. Luckily, generators for both, annotation and parameter decorators, have landed in the Angular code base lately. So what the framework behind the scenes does is, it comes with metadata annotation implementations, which are then passed to the decorator generator to make decorators out of them. That’s also why we have to write the following code when transpiling with traceur:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span>\n  ComponentMetadata <span class=\"token keyword\">as</span> Component\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'@angular/core'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>As we can see, we’re actually importing the metadata rather than the decorator. This is simply just because traceur doesn’t understand decorators, but does understand <code class=\"language-text\">@Component</code> annotations. Which is why we’re also importing them with these namespaces respectively.</p>\n<h2>Conclusion</h2>\n<p>“AtScript Annotations” and decorators are nearly the same thing. From a consumer perspective we have exactly the same syntax. The only thing that differs is that we don’t have control over how AtScript annotations are added as metadata to our code. Whereas decorators are rather an interface to build something that ends up as annotation. Over a long term, however, we can just focus on decorators, since those are a real proposed standard. AtScript is deprecated, and TypeScript implements decorators.</p>\n<p>I hope this article made some things clear though.</p>","frontmatter":{"author":"pascal_precht","title":"The difference between Annotations and Decorators","imageUrl":null,"date":"03 May 2015","summary":"Learn how AtScript annotations differ from TypeScript decorators in this article.","categories":["angular"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angular/2015/05/03/the-difference-between-annotations-and-decorators.html","previous":{"fields":{"slug":"/announcements/2015/04/19/upcoming-events-in-2015.html"},"frontmatter":{"date":"2015/04/19","title":"Upcoming events in 2015","categories":["announcements"]}},"next":{"fields":{"slug":"/announcements/2015/05/08/speaking-at-code-talks.html"},"frontmatter":{"date":"2015/05/08","title":"Speaking at code.talks","categories":["announcements"]}}}}}
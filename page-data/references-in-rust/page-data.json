{"componentChunkName":"component---src-templates-blog-post-js","path":"/references-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"20212f38-8589-5cc1-912a-66b9ef985a72","excerpt":"If youâ€™ve read our article on Rustâ€™s Ownership or if youâ€™ve written your first few programs and wondered whatâ€™s the difference between String and &str, youâ€™reâ€¦","html":"<p>If youâ€™ve read our article on <a href=\"/ownership-in-rust/\">Rustâ€™s Ownership</a> or if youâ€™ve written your first few programs and wondered <a href=\"/string-vs-str-in-rust\">whatâ€™s the difference between String and &#x26;str</a>, youâ€™re most likely aware that thereâ€™s the notion of references in Rust. References enable us to give things like functions an data structures access to values, without transferring ownership. Or, in other words, without <strong>moving</strong> them. In this article weâ€™re going to explore references a bit further and take a closer look at some interesting characteristics.</p>\n<h2>What are references again?</h2>\n<p>Just in case you havenâ€™t checked out the other linked articles, hereâ€™s a quick recap:</p>\n<p>A reference is a <strong>nonowning pointer type</strong> that references another value in memory. References are created using the borrow-operator <code class=\"language-text\">&amp;</code>, so the following code creates a variable <code class=\"language-text\">x</code> that owns <code class=\"language-text\">10</code> and a variable <code class=\"language-text\">r</code>, that is a reference to <code class=\"language-text\">x</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Since <code class=\"language-text\">10</code> is a primitive type, it gets stored on the stack and so does the reference. Hereâ€™s roughly what it looks like in memory (if â€œstackâ€ and â€œheapâ€ are terms that donâ€™t make sense to you, you should really have a look at <a href=\"/ownership-in-rust\">our article on Ownership in Rust</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   +â€“â€“â€“â€“â€“â€“â€“+\n                   â”‚       â”‚\n            +â€“â€“â€“+â€“â€“Vâ€“+â€“â€“â€“+â€“â”‚â€“+â€“â€“â€“+\nstack frame â”‚   â”‚ 10 â”‚   â”‚ â€¢ â”‚   â”‚ \n            +â€“â€“â€“+â€“â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n                [â€“â€“â€“â€“]   [â€“â€“â€“]\n                  x        r</code></pre></div>\n<p>References can point to values anywhere in memory, not just the stack frame. The following code for example, creates a <strong>string slice reference</strong> as discussed in our article on <a href=\"/string-vs-str-in-rust\">String vs &#x26;str in Rust</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> last_name <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>my_name<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>A <code class=\"language-text\">String</code> is a pointer type that points at the data stored on the <strong>heap</strong>. Notice that the string slice is a reference to a substring of that data and therefore also points at the memory on the heap:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                my_name       last_name\n            [â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“]    [â€“â€“â€“â€“â€“â€“â€“]\n            +â€“â€“â€“+â€“â€“â€“â€“+â€“â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\nstack frame â”‚ â€¢ â”‚ 16 â”‚ 13 â”‚   â”‚ â€¢ â”‚ 6 â”‚ \n            +â€“â”‚â€“+â€“â€“â€“â€“+â€“â€“â€“â€“+â€“â€“â€“+â€“â”‚â€“+â€“â€“â€“+\n              â”‚                 â”‚\n              â”‚                 +â€“â€“â€“â€“â€“â€“â€“â€“â€“+\n              â”‚                           â”‚\n              â”‚                           â”‚\n              â”‚                         [â€“â”‚â€“â€“â€“â€“â€“â€“â€“ str â€“â€“â€“â€“â€“â€“â€“â€“â€“]\n            +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n       heap â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚   â”‚ P â”‚ r â”‚ e â”‚ c â”‚ h â”‚ t â”‚   â”‚   â”‚   â”‚\n            +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+</code></pre></div>\n<p>In case of strings, itâ€™s also possible to create <strong>string literals</strong>, which are preallocated readonly memory. So for example <code class=\"language-text\">name</code> in the following code is a reference to a <code class=\"language-text\">str</code> that lives in preallocated memory as part of the program:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Which looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            name: &amp;str\n            [â€“â€“â€“â€“â€“â€“â€“]\n            +â€“â€“â€“+â€“â€“â€“+\nstack frame â”‚ â€¢ â”‚ 6 â”‚ \n            +â€“â”‚â€“+â€“â€“â€“+\n              â”‚                 \n              +â€“â€“+                \n                 â”‚\n preallocated  +â€“Vâ€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+\n read-only     â”‚ P â”‚ a â”‚ s â”‚ c â”‚ a â”‚ l â”‚\n memory        +â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+â€“â€“â€“+</code></pre></div>\n<p>Okay, so what else is there to say about references? A few things. Letâ€™s start with <strong>shared references</strong> and <strong>mutable references</strong>.</p>\n<h2>Shared and mutable references</h2>\n<p>As you probably know, variables in Rust are immutable by default. The same applies to references as well. Say we have a <code class=\"language-text\">struct Person</code> and try to compile the code below:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> u8\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">28</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n\nr<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will result in an error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0594]: cannot assign to `r.age` which is behind a `&amp;` reference\n  --&gt; src/main.rs:16:3\n   |\n14 |   let r = &amp;p;\n   |           -- help: consider changing this to be a mutable reference: `&amp;mut p`\n15 |   \n16 |   r.age = 29;\n   |   ^^^^^^^^^^ `r` is a `&amp;` reference, so the data it refers to cannot be written</code></pre></div>\n<p>You can <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=3a40de737f8c6d47284fe3e91b04598b\">see it action here</a>. Rust is very clear about the issue and tells us to make <code class=\"language-text\">&amp;p</code> mutable using the <code class=\"language-text\">mut</code> keyword. The same goes for <code class=\"language-text\">r</code> and <code class=\"language-text\">p</code> as well. However, this introduces another characteristic. There can be only one mutable reference at a time.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> p<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The code above tries to create two mutable references to the same data. If we try to compile this code, Rust will emit this error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0499]: cannot borrow `p` as mutable more than once at a time\n  --&gt; src/main.rs:15:16\n   |\n14 |   let mut r = &amp;mut p;\n   |               ------ first mutable borrow occurs here\n15 |   let mut r2 = &amp;mut p;\n   |                ^^^^^^ second mutable borrow occurs here\n16 |   \n17 |   r.age = 29;\n   |   ---------- first borrow later used here</code></pre></div>\n<p>While it may occur unexpected, it actually makes perfect sense. Rust claims to be memory safe and one of the things that make this claim true, is that there canâ€™t be multiple mutable references to the same data. Allowing multiple such references in different parts of the code, thereâ€™d be no guarantee that one of them wonâ€™t mutate the data in an unexpected way.</p>\n<p>On the other hand though, itâ€™s possible to have as many <strong>shared references</strong> of the same data as needed. So assuming <code class=\"language-text\">p</code> and <code class=\"language-text\">r</code> arenâ€™t mutable, doing this would be totally fine:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r3 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r4 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r5 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Itâ€™s even possible to have references of references!</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> rr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rrr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrrrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rrrrr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;&amp;&amp;p</span></code></pre></div>\n<p>But waitâ€¦ How would that be practical? If we pass <code class=\"language-text\">r5</code>, which really is a <code class=\"language-text\">&amp;&amp;&amp;&amp;&amp;p</code>, to a function, how is that function supposed to work with a reference to a reference to a reference to aâ€¦ you get the idea. Turns out, references can be dereferenced.</p>\n<h2>Dereferencing References</h2>\n<p>References can be dereferenced using the <code class=\"language-text\">*</code>-operator, so one can access their underlying value in memory. If we take the code snippet from earlier where <code class=\"language-text\">x</code> owned <code class=\"language-text\">10</code> and <code class=\"language-text\">r</code> held a reference to it, the reference could be dereferenced as follows for comparison:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token operator\">*</span>r <span class=\"token operator\">==</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Same!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However, letâ€™s take a look at this slightly different code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> rr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">;</span> <span class=\"token comment\">// `rr` is a `&amp;&amp;x`</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token function\">is_ten</span><span class=\"token punctuation\">(</span>rr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Same!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">is_ten</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> bool <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">*</span>val <span class=\"token operator\">==</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">is_ten()</code> takes a <code class=\"language-text\">&amp;i32</code>, or, a reference to a 32 bit signed integer. The thing we pass to it though, is actually a <code class=\"language-text\">&amp;&amp;i32</code>, or, a reference <strong>to a reference</strong> to a 32 bit signed integer.</p>\n<p>So for this to work, it looks like <code class=\"language-text\">val: &amp;i32</code> should actually be <code class=\"language-text\">val: &amp;&amp;i32</code>, and the expression <code class=\"language-text\">*val == 10</code> should be <code class=\"language-text\">**val == 10</code>. In fact, if make those changes to the code it compiles and runs as expected. You can <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=f03305d9cf51f3d242e989eab4b84019\">see it in action here</a>. However, it turns out that when <strong>not</strong> making these changes, <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=dc6b1e4414151ff45a3f123dcd6f4ac6\">the code still compiles</a>, so whatâ€™s going on there?</p>\n<p>Rustâ€™s comparison operators (things like <code class=\"language-text\">==</code> and <code class=\"language-text\">&gt;=</code> etc) are smart enough to traverse a chain of references until they reach a value, as long as both operands have the same type. This means in practice, you can have as many references to references as needed, the â€œsynctactical costâ€ stays the same as the compiler will figure it out for you!</p>\n<h2>Implicit dereferencing and borrowing</h2>\n<p>At this point, you might be wondering: How come I donâ€™t have to use the <code class=\"language-text\">*</code>-operator when calling methods on certain types?</p>\n<p>To illustrate this, letâ€™s have a look at the <code class=\"language-text\">Person</code> struct from earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> u8\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pascal <span class=\"token operator\">=</span> Person <span class=\"token punctuation\">{</span>\n    first_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    last_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span> <span class=\"token number\">28</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pascal<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>first_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that, even though weâ€™re working with a reference, we didnâ€™t have to use the <code class=\"language-text\">*</code>-operator to access the <code class=\"language-text\">first_name</code> property of <code class=\"language-text\">r</code>, which is actually a reference.\n<strong>What weâ€™re experiencing here is another usability feature of the Rust compiler</strong>. It turns out the <code class=\"language-text\">.</code>-operator performs the dereferencing implicitly, if needed!</p>\n<p>The same code can be de-sugared to:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The same applies to borrowing references and mutable references as well. For example, an arrayâ€™s <code class=\"language-text\">sort()</code> method needs a <code class=\"language-text\">&amp;mut self</code>. However, we donâ€™t have to worry about that when writing code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  numbers<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">.</code>-operator will implicitly borrow a reference to its left operand. This means, the <code class=\"language-text\">.sort()</code> call is the equivalent of:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>ğŸ¤¯ How cools is that? </p>\n<h2>Whatâ€™s next?</h2>\n<p>If thereâ€™s one more thing that should be talked about when it comes to references in Rust, itâ€™s probably its safety and lifetime characteristics. You can read more about that in our article about <a href=\"/lifetimes-in-rust/\">Lifetimes in Rust</a>!</p>","frontmatter":{"author":"pascal_precht","title":"References in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAAL/2gAMAwEAAhADEAAAAePUtziML//EABkQAAIDAQAAAAAAAAAAAAAAAAECAAMQEf/aAAgBAQABBQIJGrK4phbuf//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/AYf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwFn/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRABAQEAAwAAAAAAAAAAAAAAAQAREDFR/9oACAEBAAE/IdIQ3HfGSUZu3H//2gAMAwEAAgADAAAAEEz/AP/EABYRAAMAAAAAAAAAAAAAAAAAAAEQUf/aAAgBAwEBPxAUv//EABYRAAMAAAAAAAAAAAAAAAAAABARQf/aAAgBAgEBPxBIP//EABkQAQEBAAMAAAAAAAAAAAAAAAEAESFBcf/aAAgBAQABPxBmYk4IBogyjCk6n/Wzy3//2Q==","aspectRatio":1.4992503748125936,"src":"/static/b366f5deed09fc1fcd3072c6a203b81b/30037/galaxy.jpg","srcSet":"/static/b366f5deed09fc1fcd3072c6a203b81b/10bdc/galaxy.jpg 158w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/f4ab0/galaxy.jpg 315w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/30037/galaxy.jpg 630w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/9810d/galaxy.jpg 945w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/2f7e7/galaxy.jpg 1000w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"17 March 2020","summary":"A fundamental building block to make the language's model of Ownership work. In this article we discuss a few things to be aware of when dealing with references in Rust.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/references-in-rust/","previous":{"fields":{"slug":"/string-vs-str-in-rust/"},"frontmatter":{"date":"2020/03/03","title":"String vs &str in Rust","categories":["rust"]}},"next":{"fields":{"slug":"/iterators-in-rust/"},"frontmatter":{"date":"2020/10/08","title":"Iterators in Rust","categories":["rust"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/references-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"20212f38-8589-5cc1-912a-66b9ef985a72","excerpt":"If you’ve read our article on Rust’s Ownership or if you’ve written your first few programs and wondered what’s the difference between String and &str, you’re…","html":"<p>If you’ve read our article on <a href=\"/ownership-in-rust/\">Rust’s Ownership</a> or if you’ve written your first few programs and wondered <a href=\"/string-vs-str-in-rust\">what’s the difference between String and &#x26;str</a>, you’re most likely aware that there’s the notion of references in Rust. References enable us to give things like functions an data structures access to values, without transferring ownership. Or, in other words, without <strong>moving</strong> them. In this article we’re going to explore references a bit further and take a closer look at some interesting characteristics.</p>\n<h2>What are references again?</h2>\n<p>Just in case you haven’t checked out the other linked articles, here’s a quick recap:</p>\n<p>A reference is a <strong>nonowning pointer type</strong> that references another value in memory. References are created using the borrow-operator <code class=\"language-text\">&amp;</code>, so the following code creates a variable <code class=\"language-text\">x</code> that owns <code class=\"language-text\">10</code> and a variable <code class=\"language-text\">r</code>, that is a reference to <code class=\"language-text\">x</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Since <code class=\"language-text\">10</code> is a primitive type, it gets stored on the stack and so does the reference. Here’s roughly what it looks like in memory (if “stack” and “heap” are terms that don’t make sense to you, you should really have a look at <a href=\"/ownership-in-rust\">our article on Ownership in Rust</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                   +–––––––+\n                   │       │\n            +–––+––V–+–––+–│–+–––+\nstack frame │   │ 10 │   │ • │   │ \n            +–––+––––+–––+–––+–––+\n                [––––]   [–––]\n                  x        r</code></pre></div>\n<p>References can point to values anywhere in memory, not just the stack frame. The following code for example, creates a <strong>string slice reference</strong> as discussed in our article on <a href=\"/string-vs-str-in-rust\">String vs &#x26;str in Rust</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> last_name <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>my_name<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>A <code class=\"language-text\">String</code> is a pointer type that points at the data stored on the <strong>heap</strong>. Notice that the string slice is a reference to a substring of that data and therefore also points at the memory on the heap:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                my_name       last_name\n            [––––––––––––]    [–––––––]\n            +–––+––––+––––+–––+–––+–––+\nstack frame │ • │ 16 │ 13 │   │ • │ 6 │ \n            +–│–+––––+––––+–––+–│–+–––+\n              │                 │\n              │                 +–––––––––+\n              │                           │\n              │                           │\n              │                         [–│––––––– str –––––––––]\n            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>In case of strings, it’s also possible to create <strong>string literals</strong>, which are preallocated readonly memory. So for example <code class=\"language-text\">name</code> in the following code is a reference to a <code class=\"language-text\">str</code> that lives in preallocated memory as part of the program:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Which looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            name: &amp;str\n            [–––––––]\n            +–––+–––+\nstack frame │ • │ 6 │ \n            +–│–+–––+\n              │                 \n              +––+                \n                 │\n preallocated  +–V–+–––+–––+–––+–––+–––+\n read-only     │ P │ a │ s │ c │ a │ l │\n memory        +–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>Okay, so what else is there to say about references? A few things. Let’s start with <strong>shared references</strong> and <strong>mutable references</strong>.</p>\n<h2>Shared and mutable references</h2>\n<p>As you probably know, variables in Rust are immutable by default. The same applies to references as well. Say we have a <code class=\"language-text\">struct Person</code> and try to compile the code below:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> u8\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> <span class=\"token number\">28</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n\nr<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">29</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This will result in an error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0594]: cannot assign to `r.age` which is behind a `&amp;` reference\n  --&gt; src/main.rs:16:3\n   |\n14 |   let r = &amp;p;\n   |           -- help: consider changing this to be a mutable reference: `&amp;mut p`\n15 |   \n16 |   r.age = 29;\n   |   ^^^^^^^^^^ `r` is a `&amp;` reference, so the data it refers to cannot be written</code></pre></div>\n<p>You can <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=3a40de737f8c6d47284fe3e91b04598b\">see it action here</a>. Rust is very clear about the issue and tells us to make <code class=\"language-text\">&amp;p</code> mutable using the <code class=\"language-text\">mut</code> keyword. The same goes for <code class=\"language-text\">r</code> and <code class=\"language-text\">p</code> as well. However, this introduces another characteristic. There can be only one mutable reference at a time.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> p<span class=\"token punctuation\">;</span></code></pre></div>\n<p>The code above tries to create two mutable references to the same data. If we try to compile this code, Rust will emit this error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0499]: cannot borrow `p` as mutable more than once at a time\n  --&gt; src/main.rs:15:16\n   |\n14 |   let mut r = &amp;mut p;\n   |               ------ first mutable borrow occurs here\n15 |   let mut r2 = &amp;mut p;\n   |                ^^^^^^ second mutable borrow occurs here\n16 |   \n17 |   r.age = 29;\n   |   ---------- first borrow later used here</code></pre></div>\n<p>While it may occur unexpected, it actually makes perfect sense. Rust claims to be memory safe and one of the things that make this claim true, is that there can’t be multiple mutable references to the same data. Allowing multiple such references in different parts of the code, there’d be no guarantee that one of them won’t mutate the data in an unexpected way.</p>\n<p>On the other hand though, it’s possible to have as many <strong>shared references</strong> of the same data as needed. So assuming <code class=\"language-text\">p</code> and <code class=\"language-text\">r</code> aren’t mutable, doing this would be totally fine:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r3 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r4 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r5 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span></code></pre></div>\n<p>It’s even possible to have references of references!</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> rr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rrr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;&amp;p</span>\n<span class=\"token keyword\">let</span> rrrrr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>rrrrr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// &amp;&amp;&amp;&amp;&amp;p</span></code></pre></div>\n<p>But wait… How would that be practical? If we pass <code class=\"language-text\">r5</code>, which really is a <code class=\"language-text\">&amp;&amp;&amp;&amp;&amp;p</code>, to a function, how is that function supposed to work with a reference to a reference to a reference to a… you get the idea. Turns out, references can be dereferenced.</p>\n<h2>Dereferencing References</h2>\n<p>References can be dereferenced using the <code class=\"language-text\">*</code>-operator, so one can access their underlying value in memory. If we take the code snippet from earlier where <code class=\"language-text\">x</code> owned <code class=\"language-text\">10</code> and <code class=\"language-text\">r</code> held a reference to it, the reference could be dereferenced as follows for comparison:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token operator\">*</span>r <span class=\"token operator\">==</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Same!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However, let’s take a look at this slightly different code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> rr <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>r<span class=\"token punctuation\">;</span> <span class=\"token comment\">// `rr` is a `&amp;&amp;x`</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token function\">is_ten</span><span class=\"token punctuation\">(</span>rr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Same!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">is_ten</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> bool <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">*</span>val <span class=\"token operator\">==</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">is_ten()</code> takes a <code class=\"language-text\">&amp;i32</code>, or, a reference to a 32 bit signed integer. The thing we pass to it though, is actually a <code class=\"language-text\">&amp;&amp;i32</code>, or, a reference <strong>to a reference</strong> to a 32 bit signed integer.</p>\n<p>So for this to work, it looks like <code class=\"language-text\">val: &amp;i32</code> should actually be <code class=\"language-text\">val: &amp;&amp;i32</code>, and the expression <code class=\"language-text\">*val == 10</code> should be <code class=\"language-text\">**val == 10</code>. In fact, if make those changes to the code it compiles and runs as expected. You can <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=f03305d9cf51f3d242e989eab4b84019\">see it in action here</a>. However, it turns out that when <strong>not</strong> making these changes, <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=dc6b1e4414151ff45a3f123dcd6f4ac6\">the code still compiles</a>, so what’s going on there?</p>\n<p>Rust’s comparison operators (things like <code class=\"language-text\">==</code> and <code class=\"language-text\">&gt;=</code> etc) are smart enough to traverse a chain of references until they reach a value, as long as both operands have the same type. This means in practice, you can have as many references to references as needed, the “synctactical cost” stays the same as the compiler will figure it out for you!</p>\n<h2>Implicit dereferencing and borrowing</h2>\n<p>At this point, you might be wondering: How come I don’t have to use the <code class=\"language-text\">*</code>-operator when calling methods on certain types?</p>\n<p>To illustrate this, let’s have a look at the <code class=\"language-text\">Person</code> struct from earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Person <span class=\"token punctuation\">{</span>\n  first_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  last_name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">,</span>\n  age<span class=\"token punctuation\">:</span> u8\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pascal <span class=\"token operator\">=</span> Person <span class=\"token punctuation\">{</span>\n    first_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    last_name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    age<span class=\"token punctuation\">:</span> <span class=\"token number\">28</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>pascal<span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">.</span>first_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Notice that, even though we’re working with a reference, we didn’t have to use the <code class=\"language-text\">*</code>-operator to access the <code class=\"language-text\">first_name</code> property of <code class=\"language-text\">r</code>, which is actually a reference.\n<strong>What we’re experiencing here is another usability feature of the Rust compiler</strong>. It turns out the <code class=\"language-text\">.</code>-operator performs the dereferencing implicitly, if needed!</p>\n<p>The same code can be de-sugared to:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The same applies to borrowing references and mutable references as well. For example, an array’s <code class=\"language-text\">sort()</code> method needs a <code class=\"language-text\">&amp;mut self</code>. However, we don’t have to worry about that when writing code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  numbers<span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">.</code>-operator will implicitly borrow a reference to its left operand. This means, the <code class=\"language-text\">.sort()</code> call is the equivalent of:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>🤯 How cools is that? </p>\n<h2>What’s next?</h2>\n<p>If there’s one more thing that should be talked about when it comes to references in Rust, it’s probably its safety and lifetime characteristics. You can read more about that in our article about <a href=\"/lifetimes-in-rust/\">Lifetimes in Rust</a>!</p>","frontmatter":{"author":"pascal_precht","title":"References in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAAL/2gAMAwEAAhADEAAAAePUtziML//EABkQAAIDAQAAAAAAAAAAAAAAAAECAAMQEf/aAAgBAQABBQIJGrK4phbuf//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/AYf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwFn/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRABAQEAAwAAAAAAAAAAAAAAAQAREDFR/9oACAEBAAE/IdIQ3HfGSUZu3H//2gAMAwEAAgADAAAAEEz/AP/EABYRAAMAAAAAAAAAAAAAAAAAAAEQUf/aAAgBAwEBPxAUv//EABYRAAMAAAAAAAAAAAAAAAAAABARQf/aAAgBAgEBPxBIP//EABkQAQEBAAMAAAAAAAAAAAAAAAEAESFBcf/aAAgBAQABPxBmYk4IBogyjCk6n/Wzy3//2Q==","aspectRatio":1.4992503748125936,"src":"/static/b366f5deed09fc1fcd3072c6a203b81b/30037/galaxy.jpg","srcSet":"/static/b366f5deed09fc1fcd3072c6a203b81b/10bdc/galaxy.jpg 158w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/f4ab0/galaxy.jpg 315w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/30037/galaxy.jpg 630w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/9810d/galaxy.jpg 945w,\n/static/b366f5deed09fc1fcd3072c6a203b81b/2f7e7/galaxy.jpg 1000w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"17 March 2020","summary":"A fundamental building block to make the language's model of Ownership work. In this article we discuss a few things to be aware of when dealing with references in Rust.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/references-in-rust/","previous":{"fields":{"slug":"/string-vs-str-in-rust/"},"frontmatter":{"date":"2020/03/03","title":"String vs &str in Rust","categories":["rust"]}},"next":{"fields":{"slug":"/iterators-in-rust/"},"frontmatter":{"date":"2020/10/08","title":"Iterators in Rust","categories":["rust"]}}}}}
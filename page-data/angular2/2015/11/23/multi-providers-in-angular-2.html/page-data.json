{"componentChunkName":"component---src-templates-blog-post-js","path":"/angular2/2015/11/23/multi-providers-in-angular-2.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"8e7a4d79-6313-5d1a-9ef0-d4c76244464f","excerpt":"The new dependency injection system in Angular comes with a feature called “Multi Providers” that basically enable us, the consumer of the platform, to hook…","html":"<p>The new dependency injection system in Angular comes with a feature called “Multi Providers” that basically enable us, the consumer of the platform, to hook into certain operations and plug in custom functionality we might need in our application use case. We’re going to discuss what they look like, how they work and how Angular itself takes advantage of them to keep the platform flexible and extendible.</p>\n<h2>Recap: What is a provider?</h2>\n<p>If you’ve read our article on <a href=\"/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> you can probably skip this section, as you’re familiar with the provider terminology,  how they work, and how they relate to actual dependencies being injected. If you haven’t read about providers yet, here’s a quick recap.</p>\n<p><strong>A provider is an instruction that describes how an object for a certain token is created.</strong></p>\n<p>Quick example: In an Angular component we might have a <code class=\"language-text\">DataService</code> dependency, which we can ask for like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> DataService <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./data.service'</span><span class=\"token punctuation\">;</span>\n\n@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">AppComponent</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">dataService<span class=\"token punctuation\">:</span> DataService</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// dataService instanceof DataService === true</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We import the <strong>type</strong> of the dependency we’re asking for, and annotate our dependency argument with it in our component’s constructor. Angular knows how to create and inject an object of type <code class=\"language-text\">DataService</code>, if we configure a provider for it. This can happen either on the application module, that bootstrap our app, or in the component itself (both ways have different implications on the dependency’s life cycle and availability).</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// application module</span>\n@<span class=\"token function\">NgModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> DataService <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token comment\">// or in component</span>\n@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> DataService<span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> DataService <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">AppComponent</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>In fact, there’s a shorthand syntax we can use if the instruction is <code class=\"language-text\">useClass</code> and the value of it the same as the token, which is the case in this particular provider:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">NgModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>DataService<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token comment\">// or in component</span>\n@<span class=\"token function\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>DataService<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">AppComponent</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, whenever we ask for a dependency of type <code class=\"language-text\">DataService</code>, Angular knows how to create an object for it.</p>\n<h2>Understanding Multi Providers</h2>\n<p>With multi providers, we can basically provide <strong>multiple dependencies for a single token</strong>. Let’s see what that looks like. The following code manually creates an injector with multi providers:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token constant\">SOME_TOKEN</span><span class=\"token punctuation\">:</span> OpaqueToken <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OpaqueToken</span><span class=\"token punctuation\">(</span><span class=\"token string\">'SomeToken'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> injector <span class=\"token operator\">=</span> Injector<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> <span class=\"token constant\">SOME_TOKEN</span><span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token string\">'dependency one'</span><span class=\"token punctuation\">,</span> multi<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> <span class=\"token constant\">SOME_TOKEN</span><span class=\"token punctuation\">,</span> useValue<span class=\"token punctuation\">:</span> <span class=\"token string\">'dependency two'</span><span class=\"token punctuation\">,</span> multi<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> dependencies <span class=\"token operator\">=</span> injector<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">SOME_TOKEN</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// dependencies == ['dependency one', 'dependency two']</span></code></pre></div>\n<p><strong>Note</strong>: We usually don’t create injectors manually when building Angular applications since the platform takes care of that for us. This is really just for demonstration purposes.</p>\n<p>A token can be either a string or a type. We use a string, because we don’t want to create classes to represent a string value in DI. However, to provide better error messages in case something goes wrong, we can create our string token using <code class=\"language-text\">OpaqueToken</code>. We don’t have to worry about this too much now. The interesting part is where we’re registering our providers using the <code class=\"language-text\">multi: true</code> option.</p>\n<p>Using <code class=\"language-text\">multi: true</code> tells Angular that the provider is a multi provider. As mentioned earlier, with multi providers, we can provide multiple values for a single token in DI. That’s exactly what we’re doing. We have two providers, both have the same token but they provide different values. If we ask for a dependency for that token, what we get is a list of all registered and provided values.</p>\n<p><strong>Okay understood, but why?</strong></p>\n<p>Alright, fine. We can provide multiple values for a single token. But why in hell would we do this? Where is this useful? Good question!</p>\n<p>Usually, when we register multiple providers with the same token, the last one wins. For example, if we take a look at the following code, only <code class=\"language-text\">TurboEngine</code> gets injected because it’s provider has been registered at last:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Engine</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">TurboEngine</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> injector <span class=\"token operator\">=</span> Injector<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> Engine<span class=\"token punctuation\">,</span> deps<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> provide<span class=\"token punctuation\">:</span> Engine<span class=\"token punctuation\">,</span> useClass<span class=\"token punctuation\">:</span> TurboEngine<span class=\"token punctuation\">,</span> deps<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> engine <span class=\"token operator\">=</span> injector<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Engine<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// engine instanceof TurboEngine</span></code></pre></div>\n<p>This means, with multi providers we can basically <strong>extend</strong> the thing that is being injected for a particular token. Angular uses this mechanism to provide pluggable hooks.</p>\n<p>One of these hooks for example are validators. When creating a validator, we need to add it to the <code class=\"language-text\">NG_VALIDATORS</code> multi provider, so Angular picks it up when needed</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">@<span class=\"token function\">Directive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  selector<span class=\"token punctuation\">:</span> <span class=\"token string\">'[customValidator][ngModel]'</span><span class=\"token punctuation\">,</span>\n  providers<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n    provide<span class=\"token punctuation\">:</span> <span class=\"token constant\">NG_VALIDATORS</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">useValue</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">formControl</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// validation happens here</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    multi<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">CustomValidator</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Multi providers also can’t be mixed with normal providers. This makes sense since we either extend or override a provider for a token.</p>\n<h2>Other Multi Providers</h2>\n<p>The Angular platform comes with a couple more multi providers that we can extend with our custom code. At the time of writing these were</p>\n<ul>\n<li><strong><code class=\"language-text\">NG_VALIDATORS</code></strong> - Interface that can be implemented by classes that can act as validators</li>\n<li><strong><code class=\"language-text\">NG_ASYNC_VALIDATORS</code></strong> - Token that can be implemented by classes that can act as async validators</li>\n</ul>\n<h2>Conclusion</h2>\n<p>Multi providers are a very nice feature to implement pluggable interface that can be extended from the outside world. The only “downside” I can see is that multi providers only as powerful as what the platform provides. <code class=\"language-text\">NG_VALIDATORS</code> and <code class=\"language-text\">NG_ASYNC_VALIDATORS</code> are implemented right into the platform, which is the only reason we can take advantage of those particular multi providers. There’s no way we can introduce our own custom multi providers (with a specific token) that influences what the platform does, but maybe this is also not needed.</p>","frontmatter":{"author":"pascal_precht","title":"Multi Providers in Angular","imageUrl":null,"date":"23 November 2015","summary":"Multi-providers allow us to extend existing dependencies in Angular. Read on to learn when this is useful!","categories":["angular2"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angular2/2015/11/23/multi-providers-in-angular-2.html","previous":{"fields":{"slug":"/announcements/2015/11/19/how-we-run-trainings.html"},"frontmatter":{"date":"2015/11/19","title":"How we run trainings","categories":["announcements"]}},"next":{"fields":{"slug":"/angular/2015/12/10/ng-message-format-the-unheard-feature-in-angular.html"},"frontmatter":{"date":"2015/12/10","title":"ngMessageFormat - Angular's unheard feature","categories":["angular"]}}}}}
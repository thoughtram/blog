{"componentChunkName":"component---src-templates-blog-post-js","path":"/string-vs-str-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"7f46f230-68c7-50f4-9058-a563f13b5493","excerpt":"Most likely, soon after you’ve started your Rust journey, you ran into this scenario where you tried to work with string types (or should I say, you thought you…","html":"<p>Most likely, soon after you’ve started your Rust journey, you ran into this scenario where you tried to work with string types (or should I say, you thought you were?), and the compiler refused to compile your code because of something that looks like a string, actually isn’t a string.</p>\n<p>For example, let’s take a look at this super simple function <code class=\"language-text\">greet(name: String)</code> which takes something of type <code class=\"language-text\">String</code> and prints it to screen using the <code class=\"language-text\">println!()</code> macro:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>my_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Compiling this code will result in a compile error that looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">error[E0308]: mismatched types\n --&gt; src/main.rs:3:11\n  |\n3 |     greet(my_name);\n  |           ^^^^^^^\n  |           |\n  |           expected struct `std::string::String`, found `&amp;str`\n  |           help: try using a conversion method: `my_name.to_string()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.</code></pre></div>\n<p>You can <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=c7a2f191abc0eae9a201f1f65c6a4f12\">see this behaviour in action here</a>. Just hit the “Run” button and look at the compiler output.</p>\n<p>Luckily, Rust’s compiler is very good at telling us what’s the problem. Clearly, we’re dealing with two different types here: <code class=\"language-text\">std::string::String</code>, or short <code class=\"language-text\">String</code>, and <code class=\"language-text\">&amp;str</code>. While <code class=\"language-text\">greet()</code> expects a <code class=\"language-text\">String</code>, apparently what we’re passing to the function is something of type <code class=\"language-text\">&amp;str</code>. The compiler even provides a hint on how it can be fixed. Changing line 3 to <code class=\"language-text\">let my_name = &quot;Pascal&quot;.to_string();</code> fixes the issue.</p>\n<p>What’s going on here? What is a <code class=\"language-text\">&amp;str</code>? And why do we have to perform an explicit conversion using <code class=\"language-text\">to_string()</code>?</p>\n<h2>Understanding the <code class=\"language-text\">String</code> type</h2>\n<p>To answer these questions, it’s beneficial to have a good understanding of how Rust stores data in memory. If you haven’t read our article on <a href=\"/ownership-in-rust/\">Taking a closer look at Ownership in Rust</a> yet, I highly recommend checking it out first.</p>\n<p>Let’s take the example from above and look at how <code class=\"language-text\">my_name</code> is stored in memory, assuming that it’s of type <code class=\"language-text\">String</code> (e.g we’ve used <code class=\"language-text\">.to_string()</code> as the compiler suggested):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                     buffer\n                   /   capacity\n                 /   /  length\n               /   /   /\n            +–––+–––+–––+\nstack frame │ • │ 8 │ 6 │ &lt;- my_name: String\n            +–│–+–––+–––+\n              │\n            [–│–––––––– capacity –––––––––––]\n              │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+\n\n            [––––––– length ––––––––]</code></pre></div>\n<p>Rust will store the <code class=\"language-text\">String</code> object for <code class=\"language-text\">my_name</code> on the stack. The object comes with a pointer to a heap-allocated buffer which holds the actual data, the buffer’s capacity and the length of the data that is being stored. Given this, the size of the <code class=\"language-text\">String</code> object itself is <strong>always fixed and three words long</strong>.</p>\n<p>One of the things that make a <code class=\"language-text\">String</code> a <code class=\"language-text\">String</code>, is the capability of resizing its buffer if needed. For example, we could use its <code class=\"language-text\">.push_str()</code> method to append more text, which potentially causes the underlying buffer to increase in size (notice that <code class=\"language-text\">my_name</code> needs to be mutable to make this work):</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmy_name<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\" Precht\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>In fact, if you’re familiar with Rust’s <a href=\"https://doc.rust-lang.org/std/vec/index.html\"><code class=\"language-text\">Vec&lt;T&gt;</code></a> type, you already know what a <code class=\"language-text\">String</code> is because it’s essentially the same in behaviour and characteristics, just with the difference that it comes with guarantees of only holding well-formed UTF-8 text.</p>\n<h2>Understanding string slices</h2>\n<p>String slices (or <code class=\"language-text\">str</code>) are what we work with when we either reference a range of UTF-8 text that is “owned” by someone else, or when we create them using <strong>string literals</strong>.</p>\n<p>If we were only interested in the last name stored in <code class=\"language-text\">my_name</code>, we can get a reference to that part of the string like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmy_name<span class=\"token punctuation\">.</span><span class=\"token function\">push_str</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\" Precht\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> last_name <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>my_name<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>By specifying the range from the 7th byte (because there’s a whitespace) until the end of the buffer (”..”), <code class=\"language-text\">last_name</code> is now a <strong>string slice</strong> referencing text owned by <code class=\"language-text\">my_name</code>. It borrows it. Here’s what it looks like in memory:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            my_name: String   last_name: &amp;str\n            [––––––––––––]    [–––––––]\n            +–––+––––+––––+–––+–––+–––+\nstack frame │ • │ 16 │ 13 │   │ • │ 6 │ \n            +–│–+––––+––––+–––+–│–+–––+\n              │                 │\n              │                 +–––––––––+\n              │                           │\n              │                           │\n              │                         [–│––––––– str –––––––––]\n            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>Notice that <code class=\"language-text\">last_name</code> does not store capacity information on the stack. This is because it’s just a reference to a slice of another <code class=\"language-text\">String</code> that manages its capacity. The string slice, or <code class=\"language-text\">str</code> itself, is what’s considered ”<strong>unsized</strong>”. Also, in practice string slices are <strong>always</strong> references so their type will always be <code class=\"language-text\">&amp;str</code> instead of <code class=\"language-text\">str</code>.</p>\n<p>Okay, this explains the difference between <code class=\"language-text\">String</code>, <code class=\"language-text\">&amp;String</code> and <code class=\"language-text\">str</code> and <code class=\"language-text\">&amp;str</code>, but we haven’t actually created such a reference in our original example, did we?</p>\n<h2>Understanding string literals</h2>\n<p>As mentioned earlier, there are two cases when we’re working with string slices: we either create a reference to a sub string, or we use <strong>string literals</strong>.</p>\n<p>A string literal is created by surrounding text with double quotes, just like we did earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> my_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal Precht\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// This is a `&amp;str` not a `String`</span></code></pre></div>\n<p>The next question is, if a <code class=\"language-text\">&amp;str</code> is a slice reference to a <code class=\"language-text\">String</code> owned by someone else, who is the owner of that value given that the text is created in place?</p>\n<p>It turns out that string literals are a bit special. They are string slices that refer to <strong>“preallocated text”</strong> that is stored in <strong>read-only</strong> memory as part of the executable. In other words, it’s memory that ships with our program and doesn’t rely on buffers allocated in the heap.</p>\n<p>That said, there’s still an entry on the stack that points to that preallocated memory when the program is executed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            my_name: &amp;str\n            [–––––––––––]\n            +–––+–––+\nstack frame │ • │ 6 │ \n            +–│–+–––+\n              │                 \n              +––+                \n                 │\n preallocated  +–V–+–––+–––+–––+–––+–––+\n read-only     │ P │ a │ s │ c │ a │ l │\n memory        +–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>With a better understanding of the difference between <code class=\"language-text\">String</code> and <code class=\"language-text\">&amp;str</code>, there’s probably another question that comes up.</p>\n<h2>Which one should be used?</h2>\n<p>Obviously, this depends on a number of variables, but generally, it’s safe to say that, if the API we’re building doesn’t need to own or mutate the text it’s working with, it should take a <code class=\"language-text\">&amp;str</code> instead of a <code class=\"language-text\">String</code>. This means, an improved version of the original <code class=\"language-text\">greet()</code> function would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Wait, but what if the caller of this API really only has a <code class=\"language-text\">String</code> and can’t convert it to a <code class=\"language-text\">&amp;str</code> for unknown reasons? No problem at all. Rust has this super powerful feature called <strong>deref coercing</strong> which allows it to turn any passed <code class=\"language-text\">String</code> reference using the borrow operator, so <code class=\"language-text\">&amp;String</code>, to a <code class=\"language-text\">&amp;str</code> before the API is executed. This will be covered in more detail in another article.</p>\n<p>Our <code class=\"language-text\">greet()</code> function therefore will work with the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> first_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> last_name <span class=\"token operator\">=</span> <span class=\"token string\">\"Precht\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>first_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>last_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `last_name` is passed by reference</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fn</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, {}!\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>See it in action <a href=\"https://play.rust-lang.org/?version=stable&#x26;mode=debug&#x26;edition=2018&#x26;gist=0fd3fcd6a4a00fdebf30844a15fe6f52\">here</a>!</p>\n<p>That’s it! I hope this article was useful. There’s an <a href=\"https://www.reddit.com/r/rust/comments/fcuq8x/understanding_string_and_str_in_rust/\">interesting discussion on Reddit</a> about this content as well! Let me know what you think or what you would like to learn about next <a href=\"https://twitter.com/PascalPrecht\">on twitter</a> or sign up for the <a href=\"/categories/rust\">Rust For JavaScript Developers</a> mailing list!</p>","frontmatter":{"author":"pascal_precht","title":"String vs &str in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAFGKGFGPE//xAAbEAACAQUAAAAAAAAAAAAAAAAAASICAxITI//aAAgBAQABBQJbToOm6LIkSP/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAEBAQAAAAAAAAAAAAAAAAAAMqH/2gAIAQEABj8CteLUrFY//8QAGxABAAIDAQEAAAAAAAAAAAAAAQAxESGRYfD/2gAIAQEAAT8hCHTXkVtoybxotwnxjHNpzP/aAAwDAQACAAMAAAAQMw//xAAYEQACAwAAAAAAAAAAAAAAAAAAARExYf/aAAgBAwEBPxBIrJ0//8QAGBEBAQADAAAAAAAAAAAAAAAAAQARMWH/2gAIAQIBAT8QRdWOX//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExoYHR4f/aAAgBAQABPxB5ABbn1Eyt4QVHri8qK0uvqUcDhz8Jf3nmw//Z","aspectRatio":1.4992503748125936,"src":"/static/05d83add83590974c48b0b9cda681b46/30037/rust-letters.jpg","srcSet":"/static/05d83add83590974c48b0b9cda681b46/10bdc/rust-letters.jpg 158w,\n/static/05d83add83590974c48b0b9cda681b46/f4ab0/rust-letters.jpg 315w,\n/static/05d83add83590974c48b0b9cda681b46/30037/rust-letters.jpg 630w,\n/static/05d83add83590974c48b0b9cda681b46/9810d/rust-letters.jpg 945w,\n/static/05d83add83590974c48b0b9cda681b46/2f7e7/rust-letters.jpg 1000w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"03 March 2020","summary":"In this article we'll explore the difference between String and str in Rust and when to use which.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/string-vs-str-in-rust/","previous":{"fields":{"slug":"/resurrecting-rebase/"},"frontmatter":{"date":"2019/12/16","title":"Announcing the REBASE ebook","categories":["git"]}},"next":{"fields":{"slug":"/references-in-rust/"},"frontmatter":{"date":"2020/03/17","title":"References in Rust","categories":["rust"]}}}}}
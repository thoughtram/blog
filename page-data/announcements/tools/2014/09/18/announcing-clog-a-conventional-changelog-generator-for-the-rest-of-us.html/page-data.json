{"componentChunkName":"component---src-templates-blog-post-js","path":"/announcements/tools/2014/09/18/announcing-clog-a-conventional-changelog-generator-for-the-rest-of-us.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"698c334f-68a3-55a2-8274-caeaaf050560","excerpt":"At thoughtram we teach people how to master Git. We also teach them how to maintain a semantic history. That’s a history where each commit groups a logical code…","html":"<p>At thoughtram we teach people how to master Git. We also teach them how to maintain a semantic history. That’s a history where each commit groups a logical code change. Like a feature or a bugfix. You can go even further and follow a commit message convention to wrap up valuable meta data in the commit message. Once you follow a commit message convention, you can easily generate a nice changelog without any manual work.</p>\n<p>Let’s take a look at such a commit message.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">feat(ngInclude): add template url parameter to events\n\nThe `src` (i.e. the url of the template to load) is now provided to the\n`$includeContentRequested`, `$includeContentLoaded` and `$includeContentError`\nevents.\n\nCloses #8453\nCloses #8454</code></pre></div>\n<p>If you look closely, you might notice a pattern behind this commit message. Let’s annotate it to make things more clear.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                      component        commit title\n        commit type       /                /      \n                \\        |                |\n                 feat(ngInclude): add template url parameter to events\n            \n        body -&gt;  The &#39;src` (i.e. the url of the template to load) is now provided to the\n                 `$includeContentRequested`, `$includeContentLoaded` and `$includeContentError`\n                 events.\n\n referenced  -&gt;  Closes #8453\n issues          Closes #8454</code></pre></div>\n<p>Notice how this commit message preserves valuable meta data among the plain message. Namely the <code class=\"language-text\">commit type</code> that can either be <code class=\"language-text\">feat</code>, <code class=\"language-text\">fix</code>, <code class=\"language-text\">docs</code>, <code class=\"language-text\">style</code>, <code class=\"language-text\">refactor</code>, <code class=\"language-text\">test</code> or <code class=\"language-text\">chore</code> to indicate the <em>type</em> of the change. What follows is the name of the <em>component</em> that was changed, wrapped in parenthesis. It also contains a short title and an optional body that must have a preceding blank line.</p>\n<p>References to related issues may follow after another blank line.</p>\n<p>That’s probably not the one and only commit message convention but it’s one that is battle tested in many high profile projects. It was invented by the smart folks at Google to be used for their <a href=\"https://angularjs.org/\">AngularJS</a> project. We recommend to check out this <a href=\"https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/mobilebasic\">guideline</a> to get the full picture of the convention. Also if you like to see how the generated changelog actually looks like, take a look <a href=\"https://github.com/angular/angular.js/blob/master/CHANGELOG.md\">here</a>.</p>\n<p>Until know there’s only been a Node.js based implementation for the <a href=\"https://github.com/ajoslin/conventional-changelog\">generator</a>. In addition there is a <a href=\"https://github.com/btford/grunt-conventional-changelog\">Grunt task</a> to easily integrate it with the popular Grunt task runner.</p>\n<p>That’s all nice and simple but there’s a problem: We are leaving out a big opportunity to make more developer follow this convention. What’s about all the Java, C#, C++, Haskell, Rust or Go developers out there? They certainly won’t install Node.js or even Grunt to generate their changelog. Having Node.js as a dependency is quite a big technical debt for something as simple as changelog generation.</p>\n<h2>Hello clog!</h2>\n<p>We want changelog generation to be usable for everyone with the most minimal footprint possible. We wanted something that is aligned with the UNIX philosophy of having a small command line tool just like <code class=\"language-text\">cp</code> or <code class=\"language-text\">ls</code>. So what should we do? Write a command line tool in C? Well, almost! We’ve written a command line tool called <a href=\"https://github.com/thoughtram/clog\"><code class=\"language-text\">clog</code></a> in <a href=\"http://www.rust-lang.org/\">Rust</a>. Rust is a new language by Mozilla that enables you to write low level code in a high level language. Clog is more or less a straight port of the Node.js based <a href=\"https://github.com/ajoslin/conventional-changelog\">generator</a> by <a href=\"https://twitter.com/andrewtjoslin\">Andy Joslin</a>.</p>\n<p>clogs usage is quite simple. It follows the POSIX standard. Just invoke it with <code class=\"language-text\">clog --help</code> and you’ll get this output.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Usage:\n  clog [--repository=&lt;link&gt; --setversion=&lt;version&gt; --subtitle=&lt;subtitle&gt; \n        --from=&lt;from&gt; --to=&lt;to&gt; --from-latest-tag]</code></pre></div>\n<p>You can invoke <code class=\"language-text\">clog</code> without any parameter to generate a nice changelog for the entire history of your project. Provide the <code class=\"language-text\">--repository</code> parameter to set the URL of the github repository to make the changelog include links to the commits on github. </p>\n<p>Usually you don’t want to regenerate the entire changelog but instead prepend only the changelog for every commit that happend between now and the previous version. In order to do that you can just run clog with the <code class=\"language-text\">--from-latest-tag</code> parameter. If you know that you want to generate the changelog for a specific range of commits you can just provide the <code class=\"language-text\">--from</code> and <code class=\"language-text\">--to</code> parameters (e.g. <code class=\"language-text\">--from=c667e1e</code> <code class=\"language-text\">--to=c7a1f1c</code>).</p>\n<p>In order to also include a nice header you can provide a version and a subtitle as well (e.g. <code class=\"language-text\">--setversion=0.11.0</code> <code class=\"language-text\">--subtitle=lame-duck</code>).</p>\n<p>Putting it all together, here is how clog generated clogs latest changelog, it’s clogception!</p>\n<p><code class=\"language-text\">clog --repository=https://github.com/thoughtram/clog --from-latest-tag --setversion=0.2.0</code></p>\n<p>clog is a work in progress and there are some things missing (like exposing a C interface). That said, it’s ready to be used if you don’t mind the <a href=\"https://github.com/thoughtram/clog/issues\">missing features</a>.</p>\n<h2>How to get clog?</h2>\n<p>If you happen to use Rust for your project you can simply get clog via Rust’s package manager Cargo. Otherwise you can also just grab the binary and put it somewhere on your machine. Given the small file size you may also directly put clog into your project folder so that everyone on the team has it and changelog generation can be made part of the build process.</p>\n<p><a href=\"../assets/clog\">clog for Mac (binary)</a> <a href=\"https://github.com/thoughtram/clog\">(source)</a></p>\n<p>Binaries for Windows will follow shortly. Since none of us uses Windows, we first need figure out how to properly set up the build chain there.</p>","frontmatter":{"author":"christoph_burgdorf","title":"clog - A conventional changelog generator for the rest of us","imageUrl":null,"date":"18 September 2014","summary":"At thoughtram we teach people how to master Git. We also teach them how to maintain a semantic history. Introducing clog.","categories":["announcements","tools"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/announcements/tools/2014/09/18/announcing-clog-a-conventional-changelog-generator-for-the-rest-of-us.html","previous":{"fields":{"slug":"/git/2014/08/18/going-back-in-time-to-split-older-commits.html"},"frontmatter":{"date":"2014/08/18","title":"Going back in time to split older commits","categories":["git"]}},"next":{"fields":{"slug":"/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html"},"frontmatter":{"date":"2014/10/14","title":"One-time bindings in Angular 1.3","categories":["angularjs"]}}}}}
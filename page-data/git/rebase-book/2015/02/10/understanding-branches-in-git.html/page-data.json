{"componentChunkName":"component---src-templates-blog-post-js","path":"/git/rebase-book/2015/02/10/understanding-branches-in-git.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"2123b05b-51aa-53f2-b2f3-817111045fd6","excerpt":"In this article we will take a deep dive into Git branches. We’ll see how simple yet powerful the concept of branching in Git is. This article is part of a…","html":"<p>In this article we will take a deep dive into Git branches. We’ll see how simple yet powerful the concept of branching in Git is. This article is part of a series of articles that will also be part of our book <a href=\"https://leanpub.com/rebase-the-complete-guide-on-rebasing-in-git\">Rebase</a> which you can and should follow it’s progress on Leanpup.</p>\n<p>In our last Git article we took a detailed look on <a href=\"/git/2014/11/18/the-anatomy-of-a-git-commit.html\">the anatomy of a commit</a>. Now that we know how commits work in Git let’s expand on our knowledge and understand branches. It’s important to first grok the concept of branching in Git before we go into merging.</p>\n<h2>Starting with a simple scenario</h2>\n<p>Let’s start by looking at a simple commit history.</p>\n<p><img src=\"/07425d9b23c4ccbc64b20209dc7a7169/git-branching-commits-abstract-2.svg\" alt=\"A simple commit history\"></p>\n<p>Let’s assume our entire repository history is made up only from those three commits. There’s a pointer called <code class=\"language-text\">master</code> pointing at commit <code class=\"language-text\">a5c3eb</code>. That’s all what branches are: they are movable pointers. Let’s create a branch called <code class=\"language-text\">feature</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">git branch feature</code></pre></div>\n<p><img src=\"/70c21bbe865416334d97588bb4da9a5a/git-branching-new-branch.svg\" alt=\"Creating another branch\"></p>\n<p>Seen that? We just created another pointer called <code class=\"language-text\">feature</code> pointing at the exact same commit. Basically, all Git does it creates a file called <code class=\"language-text\">feature</code> with the contents being a 40 char string, the SHA-1 revision name of the commit.</p>\n<p>But wait! Now that we have two different branches pointing to the same commit. How does Git know which branch is currently checked out? This is where the <code class=\"language-text\">HEAD</code> pointer comes into play!</p>\n<p><img src=\"/1502fcd5826f063bb070681a078c4fbb/git-branching-head-pointer.svg\" alt=\"Understanding HEAD\"></p>\n<p>The <code class=\"language-text\">HEAD</code> is a special pointer that simply points to the currently checked out <em>branch</em> or <em>commit</em>. And again, it’s a simple file inside the <code class=\"language-text\">.git</code> folder called <code class=\"language-text\">HEAD</code> which in our case currently contains the string <em>master</em>.</p>\n<p>Ok then, what happens if we switch to our feature branch?</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">git checkout feature</code></pre></div>\n<p><img src=\"/98f70955c11277801562c3e63b068968/git-branching-head-pointer-2.svg\" alt=\"Switching branches\"></p>\n<p>Exactly, all what happened is that <code class=\"language-text\">HEAD</code> is now pointing to <code class=\"language-text\">feature</code> instead of <code class=\"language-text\">master</code>. Switching between <code class=\"language-text\">master</code> and <code class=\"language-text\">feature</code> at this point boils down to Git replacing the string <em>master</em> with <em>feature</em> in the HEAD file. Super cheap!</p>\n<p>But what happens if we now create or modify some files and make another commit? Let’s find out.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">vim file.txt\ngit add file.txt\ngit commit -m &quot;yay, that&#39;s fun!&quot;</code></pre></div>\n<p><img src=\"/4b191284084e63c8b9e265569a426245/git-branching-head-pointer-3.svg\" alt=\"Adding a new commit to feature\"></p>\n<p>We created a new commit <code class=\"language-text\">c57e22</code> and the <code class=\"language-text\">feature</code> pointer moved on to it. That’s because branches are simply movable pointers to commits. But why did <code class=\"language-text\">feature</code> move and <code class=\"language-text\">master</code> did not? Because <code class=\"language-text\">feature</code> is the currently checked out branch. And how does Git know? Because <code class=\"language-text\">HEAD</code> points to <code class=\"language-text\">feature</code>! Simple isn’t it?</p>\n<p>Let’s switch back to <code class=\"language-text\">master</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">git checkout master</code></pre></div>\n<p><img src=\"/216c77e6de0df4be406a1548b5410462/git-branching-head-pointer-4.svg\" alt=\"Switching back to master\"></p>\n<p>What happened now is that the <code class=\"language-text\">HEAD</code> pointer changed to <code class=\"language-text\">master</code> and the state of the entire working directory was changed to what it was at <code class=\"language-text\">a5c3eb</code>.</p>\n<p>Let’s modify a file and create another commit.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">vim anotherFile.txt\ngit add anotherFile.txt\ngit commit -m &quot;yay, more fun!&quot;</code></pre></div>\n<p><img src=\"/c37be685abb1c4f92303f76fcb3eca17/git-branching-head-pointer-5.svg\" alt=\"Adding a new commit to master\"></p>\n<p>A new commit <code class=\"language-text\">3aa2ff</code> appeared and <code class=\"language-text\">master</code> moved on to it. At this point our history has diverged. And this is the whole point of branches. They enable us to have parallel evolution of a code base.</p>\n<p>At this point you may be wondering how to <em>merge</em> both ends back together. This is exactly what we will look at in our next Git episode. Stay tuned!</p>\n<h2>Detached HEAD</h2>\n<p>Ever came across a detached <code class=\"language-text\">HEAD</code>? Now that we know how Git handles branches, it’s the perfect time to demystify the detached <code class=\"language-text\">HEAD</code>. You’ll be suprised how simple it is. In fact, you may have spotted a hint in the text above.</p>\n<blockquote>\n<p>The <code class=\"language-text\">HEAD</code> is a special pointer that simply points to the currently checked out <em>branch</em> or <em>commit</em></p>\n</blockquote>\n<p>Not only can we check out branches, we can also checkout any commit revision explicitly. </p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">git checkout 339aa3</code></pre></div>\n<p><img src=\"/7ac7580fb5b9791eca7c265ce8f60ab6/git-detached-head-2.svg\" alt=\"Checking out commits explicitly\"></p>\n<p>You see? What happened now is that <code class=\"language-text\">HEAD</code> points to <code class=\"language-text\">339aa3</code> explicitly and the entire working directory was changed to what it looked like at that commit.</p>\n<blockquote>\n<p>When <code class=\"language-text\">HEAD</code> points to a commit hash explicitly (rather than to a branch) it’s in a <strong>detached</strong> state.</p>\n</blockquote>\n<p>What happens if we create new commits from here? Let’s find out!</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">vim someFile.txt\ngit add someFile.txt\ngit commit -m &quot;detached HEAD fun&quot;</code></pre></div>\n<p><img src=\"/9f0fd18e6f0ea759062f1317f6f9d73f/git-detached-head-3.svg\" alt=\"Adding commits to a detached HEAD\"></p>\n<p>Let’s add one more!</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">vim someFile.txt\ngit add someFile.txt\ngit commit -m &quot;more detached HEAD fun&quot;</code></pre></div>\n<p><img src=\"/21790b11d643613a43a1039157bae9a3/git-detached-head-4.svg\" alt=\"Adding even more\"></p>\n<p>We can go on like that. Does that mean, we don’t actually need branches? Yes and no. What we just did is kinda like having a branch without a branch name. It works but there are two problems:</p>\n<ul>\n<li>How do you remember the SHA-1 key without a simple branch name?</li>\n<li>Commits that are not reachable by any branch or tag will be garbage collected and removed from the repository after 30 days.</li>\n</ul>\n<p>No need to worry though. We can simply create a new branch right here!</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">git checkout -b bugfix</code></pre></div>\n<p><img src=\"/fe6f7385644da0ec9e864f1f4a0a2594/git-detached-head-6.svg\" alt=\"Giving it a name again\"></p>\n<p>Bottom line: If in doubt, just branch. Branches are too lightweight to even think twice about them.</p>","frontmatter":{"author":"christoph_burgdorf","title":"Understanding branches in Git","imageUrl":null,"date":"10 February 2015","summary":"In this article we will take a deep dive into Git branches. We'll see how simple yet powerful the concept of branching in Git is.","categories":["git","rebase-book"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/git/rebase-book/2015/02/10/understanding-branches-in-git.html","previous":{"fields":{"slug":"/angularjs/es6/2015/01/23/exploring-angular-1.3-using-es6.html"},"frontmatter":{"date":"2015/01/23","title":"Using ES2015 with Angular today","categories":["angularjs","es6"]}},"next":{"fields":{"slug":"/angularjs/2015/02/19/futuristic-routing-in-angular.html"},"frontmatter":{"date":"2015/02/19","title":"Futuristic Routing in Angular","categories":["angularjs"]}}}}}
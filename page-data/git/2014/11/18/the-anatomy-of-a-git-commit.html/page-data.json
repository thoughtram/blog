{"componentChunkName":"component---src-templates-blog-post-js","path":"/git/2014/11/18/the-anatomy-of-a-git-commit.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"70705e90-f4a1-5a97-a004-6246bcb2738c","excerpt":"Ever wondered what a Git commit looks like internally? Why it has those long revision identifiers? If they are unique or not? We are going to look at exactly…","html":"<p>Ever wondered what a Git commit looks like internally? Why it has those long revision identifiers? If they are unique or not? We are going to look at exactly that!</p>\n<h2>What’s up with those long revision names?</h2>\n<p>One of the first things people notice when they switch from other version controls to Git is that revisions use hard to remember 40 char long hashes. Why do that if you can just use revision names such as <code class=\"language-text\">r4711</code>, <code class=\"language-text\">r4712</code> etc? The short answer: Git has integrity. </p>\n<p>If you and me both look at revision <code class=\"language-text\">f4f78b319c308600eab015a5d6529add21660dc1</code> on our machines and Git tells us that we have a clean working directory, we can be 100% sure that we are looking at exactly the same files. There is no way someone could manipulate a single bit without Git knowing about it.</p>\n<p>This is especially important in an distributed version control system. There’s no chance that bits could go lost in transit without Git noticing it.</p>\n<h2>Introducing SHA-1</h2>\n<p>Those 40 character revision identifiers are actually SHA-1 hashes. So what is a SHA-1 hash? SHA-1 is an algorithm and what it does is: it takes some data as input and generates a unique 40 character string from it. So what does unique mean in that context? Unique means that no other input data should ever produce the same hash. The same input data however should always produce exactly the same hash.</p>\n<p>If you are on a UNIX system, try this out.</p>\n<p><code class=\"language-text\">echo -n &quot;thoughtram&quot; | openssl sha1</code></p>\n<p>This should print out <code class=\"language-text\">a9eb85ea214a6cfa6882f4be041d5cce7bee3e45</code> no matter if you run it on your machine or I on mine. It’s the SHA-1 representation of the string <code class=\"language-text\">thoughtram</code>.</p>\n<h2>Hashes over hashes</h2>\n<p>Now that we know what a hash is, we find us wondering, what exactly is the input data that Git uses to get to the commit hash? Let’s start with a very abstract idea and iterate on it until we have a strong understanding of Git’s internal commit representation. In principle it looks like this in pseudo code.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sha1(\n    meta data\n        commit message\n        committer\n        commit date\n        author\n        authoring date\n    Hash-Of-Entire-Working-Directory (bear, with me!)\n)</code></pre></div>\n<p>It’s a SHA-1 hash over a bunch of meta data (commit message etc) and the hash of the entire snapshot of the working directory with all it’s files and folders. Let that sink in for a second. It’s a hash over some meta data and another hash. So what exactly is this other hash that we hash again?</p>\n<h2>Meet the tree object</h2>\n<p>There are four types of objects in Git’s internal storage. Commit objects, annotated tag objects, blobs and tree objects. In order to fully understand Git’s internal representation of commits, we first need to understand tree objects.</p>\n<p>When I said <code class=\"language-text\">Hash-Of-Entire-Working-Directory</code> I made a bit of an oversimplification. Yes it’s true, it’s a hash over the entire working directory with all it’s files and folders excluding ignored files. But at the same time it’s not quite <em>that</em> simple. Let’s assume the following project structure and then examine how it is represented with the corresponding tree object.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.\n├── .git (contents left out)\n├── assets\n|   ├── logo.png\n|   └── app.css\n└── app.js</code></pre></div>\n<p>Here is what Git’s representation of the working directory looks like.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 800px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/48bfa999396d42d3055d4543d41cfe8b/f570d/git_tree.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAACpUlEQVQ4y61UXUiTURg+85PCkLqpK5GCLLMsgy7UC8kpFNRNXUR0UUEXBgX9oBdS6U2pSUXf1C7KUow2f6a2uT/ddLbNTTf3Ofejpput5VySWPYnBtXp+b7lSBAh8cDL877nO+97nvfnfKS5q/9kl2N8TD844dANjHGd9tectn+U0w/6ndi3Yz/QbnQWE6zxud/MHbaWV8lzhZGsuF72cvm97pAS0ohgMoPTL0Mgqdrqk+MCWTc3qVSYXOf/9dmdtp+sZTGQBF65UcYS17uvm8y+cAKldHUvd3hBhEOigmvFjKrPqzNwgXmkGQHbCBjOAGfAOMIL7HB5VV0m3EQZhzI3rhjwhcq0pIrgNMQF56llZJoiMLX4pqnJOyUI2NFe91v6tEWXzR/esXNXYjT9dFJYUkGu3yojx06cJqS+TR8L3tYzeFBrGxGr+7xiqdqc12pw5ErVpvz6NsMRMM3tMLvFKotnc/Ht+3E5eUcT+cxQCib8gzKhBcqUVtZEAyUlbyfrtur+MpRpLCIe5QZ7KhhqgHlLZx43qpKVpmEJ2NV0WDys4tWQpKWrH7qbBWsWWIW9e5eKSrbEAsv1diFgU6ctxegKPsLspS99a1D0ZPnnKQ19p3R8jlL/J0oDsCc/RzH4jVLf+0V67uLV1GVsx2Z/LbObdNY4HmubtUlo2EPMqERj9bGoM4uaskrzcDVvQ5eA6YPsw/nJMWfH5EcBRz/8JJ7phXg0Q2A8MDH7PxWMj2kpqXsF3LMvg2TliJddwiOyY75AphYpw3e3Udu3AU/UhtmsQEkOIIM3KNPxVa+7cLlQwLMFV4Q5Kyq9S2oa2oW9ksrqODTpVGu3Iw2N3YbUzwC3rmkynjRp1m/M8HcS8Ga5hGCUmBb9gOiZvJNgnBi8IvIHSeCUFPhKyX0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"git tree\"\n        title=\"git tree\"\n        src=\"/static/48bfa999396d42d3055d4543d41cfe8b/8ff1e/git_tree.png\"\n        srcset=\"/static/48bfa999396d42d3055d4543d41cfe8b/9ec3c/git_tree.png 200w,\n/static/48bfa999396d42d3055d4543d41cfe8b/c7805/git_tree.png 400w,\n/static/48bfa999396d42d3055d4543d41cfe8b/8ff1e/git_tree.png 800w,\n/static/48bfa999396d42d3055d4543d41cfe8b/f570d/git_tree.png 960w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Each file is stored as a blob object. So what does that mean? Let’s keep things simple and just assume that Git generates the SHA-1 hash of the contents of <code class=\"language-text\">logo.png</code> and puts it somewhere addressable as <code class=\"language-text\">aa1b2fb696a831c89c53f787e03d863691d2b671</code>. It also generates the SHA-1 hash of the contents of <code class=\"language-text\">app.css</code> and puts it somewhere addressable as <code class=\"language-text\">4c511f16ef2644854d04cabebfcecc82be0eb04f</code>. Same goes for the <code class=\"language-text\">app.js</code> file. Notice that at this point Git doesn’t even link the file name <code class=\"language-text\">logo.png</code> with the hash <code class=\"language-text\">aa1b2fb696a831c89c53f787e03d863691d2b671</code>. This is done on a higher level for good reasons.</p>\n<p>Both <code class=\"language-text\">logo.png</code> and <code class=\"language-text\">app.css</code> are in the same directory: <code class=\"language-text\">assets</code>. And this directory, <code class=\"language-text\">assets</code> is represented as a tree object. So what is the tree object? The tree object works like a dictionary. It maps names to SHA-1 hashes. Behind those hashes there may be simple files (represented as blobs) or other tree objects.</p>\n<p>In our example, it maps the name <code class=\"language-text\">logo.png</code> to the hash <code class=\"language-text\">aa1b2fb696a831c89c53f787e03d863691d2b671</code> and the name <code class=\"language-text\">app.css</code> to the name <code class=\"language-text\">4c511f16ef2644854d04cabebfcecc82be0eb04f</code>. Eventually the dictionary (the tree object) itself is also hashed and represented by the SHA-1 hash <code class=\"language-text\">7cf2a17f3345635d59e063cffddd23573b6e4a75</code>.</p>\n<p>We aren’t done yet. Both the <code class=\"language-text\">assets</code> folder and the <code class=\"language-text\">app.js</code> file are in the same directory. It’s the top level directory and again it works like a dictionary. It maps the name <code class=\"language-text\">assets</code> to the hash <code class=\"language-text\">7cf2a17f3345635d59e063cffddd23573b6e4a75</code> (the child tree object!) and the name <code class=\"language-text\">app.js</code> to the hash <code class=\"language-text\">29bfcf9fa5824331081b31f0c307806c6f6b6f06</code>. And then again the dictionary itself is also hashed and becomes the root tree object with hash <code class=\"language-text\">9c435a86e664be00db0d973e981425e4a3ef3f8d</code>.</p>\n<p>Let that sink in again, <code class=\"language-text\">9c435a86e664be00db0d973e981425e4a3ef3f8d</code> is the hash of the root tree object which essentially translates into a dictionary that maps names to hashes and those hashes can refer to blobs (for files) or other tree objects which in turn are dictionaries themselves that map names to hashes which can refer to…ah well, you get the idea.</p>\n<h2>The commit object</h2>\n<p>Let’s go back to our commit object from above and fill it with life. Let’s assume we freshly started the repository and this is our initial commit. What follows is again pseudo code to demonstrate what exactly is used to get to the commit hash.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sha1(\n    commit message  =&gt; &quot;initial commit&quot;\n    committer        =&gt; Christoph Burgdorf &lt;christoph.burgdorf@gmail.com&gt;\n    commit date     =&gt; Sat Nov 8 10:56:57 2014 +0100\n    author          =&gt; Christoph Burgdorf &lt;christoph.burgdorf@gmail.com&gt;\n    author date     =&gt; Sat Nov 8 10:56:57 2014 +0100\n    tree            =&gt; 9c435a86e664be00db0d973e981425e4a3ef3f8d\n)</code></pre></div>\n<p>It’s all the meta data plus the hash of the root tree object. And of course Git creates a SHA-1 hash from those contents. The commit hash.</p>\n<p>Remember that I said Git has integrity? You can’t change a single thing about this commit without getting a different SHA-1 commit hash. Want to change the commit message? The commit message is part of the content that is used to produce the SHA-1 hash, changing it will change the commit hash. What if we just add a whitespace somewhere in <code class=\"language-text\">app.css</code>? Doesn’t matter. The SHA-1 hash of <code class=\"language-text\">app.css</code> won’t be <code class=\"language-text\">4c511f16ef2644854d04cabebfcecc82be0eb04f</code> anymore and that in turn will cause the <code class=\"language-text\">assets</code> tree object to not be <code class=\"language-text\">7cf2a17f3345635d59e063cffddd23573b6e4a75</code> anymore and that in turn will cause the root tree object to not be <code class=\"language-text\">9c435a86e664be00db0d973e981425e4a3ef3f8d</code> anymore. That’s integrity.</p>\n<p><em>Update</em></p>\n<p>It was <a href=\"http://www.reddit.com/r/git/comments/2mocvq/the_anatomy_of_a_git_commit/cm6unkp\">pointed out on reddit</a> that not only the metadata and the hash of the tree are hashed to become the commit hash but also the hash(es) of the parent commit(s). I left this out intentionally in order to lower the complexity of the post. For the curious reader, this is closer to what Git does in practice.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sha1(\n    commit message  =&gt; &quot;second commit&quot;\n    committer        =&gt; Christoph Burgdorf &lt;christoph.burgdorf@gmail.com&gt;\n    commit date     =&gt; Sat Nov 8 11:13:49 2014 +0100\n    author          =&gt; Christoph Burgdorf &lt;christoph.burgdorf@gmail.com&gt;\n    author date     =&gt; Sat Nov 8 11:13:49 2014 +0100\n    tree            =&gt; 9c435a86e664be00db0d973e981425e4a3ef3f8d\n    parents         =&gt; [0d973e9c4353ef3f8ddb98a86e664be001425e4a]\n)</code></pre></div>\n<h2>Recap</h2>\n<p>In this post, we explored what Git’s long revision numbers are about and how they provided integrity using a solid cryptographic approach.</p>\n<p>Please note that I simplified some parts intentionally in order to reduce the noise and make the essence easier to grasp. If you like to dig deeper, I highly recommend to read up on the <a href=\"http://git-scm.com/book/en/v2/Git-Internals-Git-Objects\">Git’s internals</a>.</p>\n<p>This post is part of a future blog series about Git internals and will also be part of our book <a href=\"https://leanpub.com/rebase-the-complete-guide-on-rebasing-in-git\">rebase - the complete guide on rebasing in git</a>.</p>","frontmatter":{"author":"christoph_burgdorf","title":"The anatomy of a Git commit","imageUrl":null,"date":"18 November 2014","summary":"In this article we explore what a Git commit looks like internally and how Git uses cryptographic tooling to enforce integrity.","categories":["git"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/git/2014/11/18/the-anatomy-of-a-git-commit.html","previous":{"fields":{"slug":"/angularjs/2014/11/06/exploring-angular-1.3-angular-hint.html"},"frontmatter":{"date":"2014/11/06","title":"Angular-hint in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2014/11/19/exploring-angular-1.3-stateful-filters.html"},"frontmatter":{"date":"2014/11/19","title":"Stateful filters in Angular 1.3","categories":["angularjs"]}}}}}
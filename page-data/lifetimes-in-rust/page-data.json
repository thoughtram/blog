{"componentChunkName":"component---src-templates-blog-post-js","path":"/lifetimes-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"98d06ed2-02da-5cd0-9d75-41a3a0fea032","excerpt":"Lifetimes are one of the most important, yet probably one of the least understood topics in the Rust programming language. That’s no surprise, because they can…","html":"<p>Lifetimes are one of the most important, yet probably one of the least understood topics in the Rust programming language. That’s no surprise, because they can be hard to grok, especially if there’s lack of understanding in how Rust manages memory. What are they, why do they exists and when do we need them? We’re going to explore all that in this article.</p>\n<h2>Let’s start with a little scenario</h2>\n<p>The first time I heard about the term “lifetime” in the context of Rust, was when I tried implement some struct that holds a reference to another struct instance. If you’re coming from other languages, it is in a way the equivalent of having some object holding another object or reference to it. In my case, I wanted to share a reference to some <code class=\"language-text\">Config</code> across different places in my application, so the code looked something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the ampersand syntax (<code class=\"language-text\">&amp;Config</code>) doesn’t make a lot of sense to you, you might want to read my article on <a href=\"/references-in-rust/\">References in Rust</a> first and come back once you’re done. Either way, if we try to compile this code, we’ll get the following error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0106]: missing lifetime specifier\n --&gt; src/lib.rs:6:13\n  |\n6 |     config: &amp;Config\n  |             ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n5 | struct App&lt;&#39;a&gt; {\n6 |     config: &amp;&#39;a Config</code></pre></div>\n<p>Apparently the compiler wants something that’s called a <strong>named lifetime parameter</strong>, whatever that is, and it also tells us exactly what that needs to look like. If we change our <code class=\"language-text\">App</code> struct accordingly, the code compiles.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Well… cool so we’ve added a bunch of weird syntax to our code and the compiler is happy, but what exactly is going on here?</p>\n<p>The short answer is that we tell the compiler, that <code class=\"language-text\">config</code>, which is of type <code class=\"language-text\">&amp;Config</code>, has the same lifetime as <code class=\"language-text\">App</code>. That lifetime happens to be called <code class=\"language-text\">a</code> but could be called really anything else. Because they both have the same lifetime, <code class=\"language-text\">App</code> is not allowed to outlive the referene to <code class=\"language-text\">Config</code>, otherwise it would be a dangling pointer, which Rust doesn’t allow by design.</p>\n<p>Uff.. what? Yea, right. Let’s roll back a bit.</p>\n<h2>On Reference Safety</h2>\n<p>Rust claims to be memory safe and we’ve talked about that to some extend in this article on <a href=\"/ownership-in-rust/\">Ownership in Rust</a>. In there, we’ve discussed that Rust “drops” values from memory that go “out of scope” and a scope is pretty much anything that introduces a new block (a lexical block, a statement, an expression etc). Take for example this function:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"Have a nice day\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `s` is dropped here</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The variable <code class=\"language-text\">s</code> is defined inside of <code class=\"language-text\">greeting</code> and a soon as the function is done doing its work, <code class=\"language-text\">s</code> is no longer needed so Rust will drop its value, freeing up the memory. We could say that <code class=\"language-text\">s</code> “lives” as long as the execution of <code class=\"language-text\">greeting</code>.</p>\n<p>This is an important concept, especially when it comes to using <a href=\"/references-in-rust/\">references in Rust</a>. Whenever we use references, Rust tries to assign them a <strong>lifetime</strong> that matches the constraints by how their used. Here’s a simple example of that:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We introduce a variable <code class=\"language-text\">r</code>, that receives a reference to <code class=\"language-text\">x</code> in the following block. Notice that the square brackets really just introduce a new block. We probably wouldn’t use them like that in real world applications. After that we print the value of <code class=\"language-text\">r</code>.</p>\n<p>However, we’ll quickly learn that the compiler isn’t really happy about this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `x` does not live long enough\n --&gt; src/main.rs:6:13\n  |\n6 |         r = &amp;x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |     println!(&quot;{}&quot;, r)\n  |                    - borrow later used here</code></pre></div>\n<p>This makes sense. We’re printing the value of <code class=\"language-text\">r</code> which holds a reference to <code class=\"language-text\">x</code>, but <code class=\"language-text\">x</code> is dropped from memory before that. In other words, <code class=\"language-text\">r</code> outlives <code class=\"language-text\">x</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>  –––––––––––––––<span class=\"token operator\">+</span>\n    <span class=\"token punctuation\">{</span>       –––––––––––––<span class=\"token operator\">+</span> <span class=\"token operator\">|</span>\n        <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>       <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>––– <span class=\"token comment\">// Lifetime of `&amp;x`</span>\n        r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>          <span class=\"token operator\">|</span> <span class=\"token operator\">|</span>\n    <span class=\"token punctuation\">}</span>       –––––––––––––<span class=\"token operator\">+</span> <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>––– <span class=\"token comment\">// Lifetime of `r`</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> –––––<span class=\"token operator\">+</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In other words, if the reference doesn’t live at least as long as the variable does, <code class=\"language-text\">r</code> will be a dangling pointer at some point.</p>\n<p>This might feel like an annoying characteristic of the Rust compiler, but it’s actually an extremely powerful feature. Let this sink in for a second: <strong>The compiler is able to derive from your code if and where you’re trying to access a variable that potentially points to nothing.</strong> 🤯</p>\n<p>To make the code above work, we obviously have to move <code class=\"language-text\">x</code> in a way that its lifetime encloses the one of <code class=\"language-text\">r</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Sweet. We understand the concept of lifetimes now, but we still don’t know when and why we need to apply this weird syntax (<code class=\"language-text\">&lt;&#39;a&gt;</code>) from earlier. Let’s dig into that by looking at lifetimes and function arguments.</p>\n<h2>Lifetimes and Arguments</h2>\n<p>Given what we’ve learned so far, we might wonder how these concepts apply to functions that take references as arguments. You might have already guessed that there’s no magic mechanism that removes the idea of lifetimes in Rust, just because a reference is passed to a function. Let’s take a look at the function below, which takes any argument that’s of type <code class=\"language-text\">&amp;i32</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">some_function</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>What we don’t see here, is that Rust actually expands this code as if it was written like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> some_function<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Look, there’s the <code class=\"language-text\">&lt;&#39;a&gt;</code> again! What’s going on here? We’ve just written out explicitly what Rust allows us to omit. <code class=\"language-text\">&#39;a</code> is a <strong>lifetime parameter</strong> of our <code class=\"language-text\">some_function</code>. It doesn’t really matter at this point that we call it <code class=\"language-text\">&#39;a</code>, we might as well call it <code class=\"language-text\">&#39;foo</code> or <code class=\"language-text\">&#39;lifetime</code>, however it’s convenient to give it some name that is enumerable (like the alphabet), because there could be more than one lifetime parameter, but more on that later. <strong>Keep in mind however, that lifetimes are a compile-time feature and don’t exist at runtime</strong>.</p>\n<p>With this signature we’re basically saying: <code class=\"language-text\">some_function</code> takes a reference to an <code class=\"language-text\">i32</code> with any given lifetime <code class=\"language-text\">&#39;a</code>. This is enough information for the compiler to know that <code class=\"language-text\">some_function</code> won’t save <code class=\"language-text\">val</code> anywhere that might outlife the call. It would be different if <code class=\"language-text\">some_function</code> took a lifetime parameter of <code class=\"language-text\">&#39;static</code>, which is Rust’s lifetime for anything that is considered global. In such a case, whatever is passed to the function, needs to live at least as long. By definition, only `static values would match that constraint.</p>\n<p>The same applies to functions that return references as well!</p>\n<h2>Returning References</h2>\n<p>Fairly often, functions take references to data structures and return a reference that points <strong>into</strong> that structure. The following function illustrates this case:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">smallest_number</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span>i32 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> r <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> r <span class=\"token operator\">&lt;</span> s <span class=\"token punctuation\">{</span>\n            s <span class=\"token operator\">=</span> r<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    s\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">smallet_number</code> takes a reference to a vector of numbers and returns a reference to a number. By default, Rust will assume that these two references have the same lifetime. So the function signature will be expanded to:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> smallest_number<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> <span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32 <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again, we’re basically saying: For any lifetime <code class=\"language-text\">&#39;a</code>, <code class=\"language-text\">smallest_number</code> takes a <code class=\"language-text\">&amp;[i32]</code> and returns a <code class=\"language-text\">&amp;i32</code> that has the same lifetime. This ensures that we can’t borrow the returned reference from <code class=\"language-text\">smallest_number</code> if it doesn’t life at least as long as the variable we’ve assigned it to. In other words, if we try to compile the this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    s <span class=\"token operator\">=</span> <span class=\"token function\">smallest_number</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Rust will tell us that <code class=\"language-text\">numbers</code> doesn’t live long enough:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `numbers` does not live long enough\n --&gt; src/main.rs:5:29\n  |\n5 |         s = smallest_number(&amp;numbers);\n  |                             ^^^^^^^^ borrowed value does not live long enough\n6 |     }\n  |     - `numbers` dropped here while still borrowed\n7 |     println!(&quot;{}&quot;, s)\n  |                    - borrow later used here</code></pre></div>\n<p>Coming back to the scenario we started out with, namely structs that contain references, things make much more sense now.</p>\n<h2>Structs with references</h2>\n<p>When it comes to actual type definitions, like the ones we’ve started out with in this article, as soon as it contains references, we have to write out their lifetimes. The code below won’t compile.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>While this one does:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You might be wondering: Why can’t the compiler simply expand our types with lifetimes just like it does with functions?</p>\n<p>Good question! Turns out, earlier versions of the compiler actually did exactly that. However, developers found that part confusing and preferred it to know exactly when one value borrows something from another.</p>\n<p>One last thing to note here, if <code class=\"language-text\">App</code> was borrowed in another type, that type will have to define its lifetime parameters as well:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Platform<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    app<span class=\"token punctuation\">:</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Lifetime parameters of different lifetimes</h2>\n<p>Of course, it’s also possible for functions and types to contain references of <strong>different</strong> lifetimes. Say we have a struct <code class=\"language-text\">Point</code> that takes <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> which are both <code class=\"language-text\">&amp;i32</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We’ve already learned that we have to write out the lifetimes of the references, so we could go ahead and define them like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That’s fine, as long as <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> have indeed the same lifetime. For example, the following code would compile:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">let</span> point <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However, as soon as <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> have different lifetimes and we’re trying to reference one of them outside of the smallest scope, things are not going to fly.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> point <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        r <span class=\"token operator\">=</span> point<span class=\"token punctuation\">.</span>x\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Rust will have to find a lifetime that works for <code class=\"language-text\">point.x</code> and <code class=\"language-text\">point.y</code> but also <strong>encloses</strong> <code class=\"language-text\">r</code>’s lifetime. Since this code doesn’t satisfy that constraint we’ll get a compile error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `y` does not live long enough\n  --&gt; src/main.rs:12:39\n   |\n12 |         let point = Point { x: &amp;x, y: &amp;y };\n   |                                       ^^ borrowed value does not live long enough\n13 |         r = point.x\n14 |     }\n   |     - `y` dropped here while still borrowed\n15 |     println!(&quot;{}&quot;, r);\n   |                    - borrow later used here</code></pre></div>\n<p>To get around this, we can simply say that <code class=\"language-text\">Point</code> has multiple distinct lifetime parameters by extending the type definition like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a,</span> <span class=\"token lifetime-annotation symbol\">'b</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'b</span> i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>Alright, so we’ve talked about the fact that Rust keeps its references under control by assigning lifetimes to them. Lifetimes are a compile-time only feature and don’t exist at runtime. They ensure that types containing references don’t outlive their them, which basically prevents us from writing code that produces dangling poitners. We also learned that in many cases, lifetime definitions can be omitted and Rust fills in the gaps for us. It’s also possible to have types with multiple distinct lifetime parameters.</p>\n<p>I hope this article gave you a better idea of what lifetimes are, how they work and when and why they are needed.</p>","frontmatter":{"author":"pascal_precht","title":"Lifetimes in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABVdsxnCg//8QAGxAAAwACAwAAAAAAAAAAAAAAAQIDABEEEyL/2gAIAQEAAQUCSYefTrHHvjjU6uyjP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/Aaf/xAAbEAACAwADAAAAAAAAAAAAAAABAgAQERIhMf/aAAgBAQAGPwLir4wmMSYfK6Nf/8QAGhABAQEBAAMAAAAAAAAAAAAAAREAMRAhsf/aAAgBAQABPyGiCq0wkIPrrQgvqYhTr3AGHfH/2gAMAwEAAgADAAAAELQv/8QAFREBAQAAAAAAAAAAAAAAAAAAAQD/2gAIAQMBAT8QAkv/xAAXEQEAAwAAAAAAAAAAAAAAAAABEBEx/9oACAECAQE/EFtsf//EABoQAQEBAQEBAQAAAAAAAAAAAAERACFhMUH/2gAIAQEAAT8QqQE07fk81oOgVkKzwwUwoAhzmIed1+usKMWGd//Z","aspectRatio":1.7794253938832252,"src":"/static/7d645708f8d10881ad143fcda83a259c/30037/lifetimes.jpg","srcSet":"/static/7d645708f8d10881ad143fcda83a259c/10bdc/lifetimes.jpg 158w,\n/static/7d645708f8d10881ad143fcda83a259c/f4ab0/lifetimes.jpg 315w,\n/static/7d645708f8d10881ad143fcda83a259c/30037/lifetimes.jpg 630w,\n/static/7d645708f8d10881ad143fcda83a259c/9810d/lifetimes.jpg 945w,\n/static/7d645708f8d10881ad143fcda83a259c/ff2e4/lifetimes.jpg 1260w,\n/static/7d645708f8d10881ad143fcda83a259c/14dee/lifetimes.jpg 1920w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"20 October 2020","summary":"Learn what Lifetimes are, why they exist and when you need them. This and more we'll explore in this article.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/lifetimes-in-rust/","previous":{"fields":{"slug":"/iterators-in-rust/"},"frontmatter":{"date":"2020/10/08","title":"Iterators in Rust","categories":["rust"]}},"next":{"fields":{"slug":"/announcements/2024/02/13/farewell.html"},"frontmatter":{"date":"2024/02/13","title":"Farewell","categories":["announcements"]}}}}}
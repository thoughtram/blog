{"componentChunkName":"component---src-templates-blog-post-js","path":"/lifetimes-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"98d06ed2-02da-5cd0-9d75-41a3a0fea032","excerpt":"Lifetimes are one of the most important, yet probably one of the least understood topics in the Rust programming language. That‚Äôs no surprise, because they can‚Ä¶","html":"<p>Lifetimes are one of the most important, yet probably one of the least understood topics in the Rust programming language. That‚Äôs no surprise, because they can be hard to grok, especially if there‚Äôs lack of understanding in how Rust manages memory. What are they, why do they exists and when do we need them? We‚Äôre going to explore all that in this article.</p>\n<h2>Let‚Äôs start with a little scenario</h2>\n<p>The first time I heard about the term ‚Äúlifetime‚Äù in the context of Rust, was when I tried implement some struct that holds a reference to another struct instance. If you‚Äôre coming from other languages, it is in a way the equivalent of having some object holding another object or reference to it. In my case, I wanted to share a reference to some <code class=\"language-text\">Config</code> across different places in my application, so the code looked something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If the ampersand syntax (<code class=\"language-text\">&amp;Config</code>) doesn‚Äôt make a lot of sense to you, you might want to read my article on <a href=\"/references-in-rust/\">References in Rust</a> first and come back once you‚Äôre done. Either way, if we try to compile this code, we‚Äôll get the following error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0106]: missing lifetime specifier\n --&gt; src/lib.rs:6:13\n  |\n6 |     config: &amp;Config\n  |             ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n5 | struct App&lt;&#39;a&gt; {\n6 |     config: &amp;&#39;a Config</code></pre></div>\n<p>Apparently the compiler wants something that‚Äôs called a <strong>named lifetime parameter</strong>, whatever that is, and it also tells us exactly what that needs to look like. If we change our <code class=\"language-text\">App</code> struct accordingly, the code compiles.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Well‚Ä¶ cool so we‚Äôve added a bunch of weird syntax to our code and the compiler is happy, but what exactly is going on here?</p>\n<p>The short answer is that we tell the compiler, that <code class=\"language-text\">config</code>, which is of type <code class=\"language-text\">&amp;Config</code>, has the same lifetime as <code class=\"language-text\">App</code>. That lifetime happens to be called <code class=\"language-text\">a</code> but could be called really anything else. Because they both have the same lifetime, <code class=\"language-text\">App</code> is not allowed to outlive the referene to <code class=\"language-text\">Config</code>, otherwise it would be a dangling pointer, which Rust doesn‚Äôt allow by design.</p>\n<p>Uff.. what? Yea, right. Let‚Äôs roll back a bit.</p>\n<h2>On Reference Safety</h2>\n<p>Rust claims to be memory safe and we‚Äôve talked about that to some extend in this article on <a href=\"/ownership-in-rust/\">Ownership in Rust</a>. In there, we‚Äôve discussed that Rust ‚Äúdrops‚Äù values from memory that go ‚Äúout of scope‚Äù and a scope is pretty much anything that introduces a new block (a lexical block, a statement, an expression etc). Take for example this function:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"Have a nice day\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `s` is dropped here</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The variable <code class=\"language-text\">s</code> is defined inside of <code class=\"language-text\">greeting</code> and a soon as the function is done doing its work, <code class=\"language-text\">s</code> is no longer needed so Rust will drop its value, freeing up the memory. We could say that <code class=\"language-text\">s</code> ‚Äúlives‚Äù as long as the execution of <code class=\"language-text\">greeting</code>.</p>\n<p>This is an important concept, especially when it comes to using <a href=\"/references-in-rust/\">references in Rust</a>. Whenever we use references, Rust tries to assign them a <strong>lifetime</strong> that matches the constraints by how their used. Here‚Äôs a simple example of that:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We introduce a variable <code class=\"language-text\">r</code>, that receives a reference to <code class=\"language-text\">x</code> in the following block. Notice that the square brackets really just introduce a new block. We probably wouldn‚Äôt use them like that in real world applications. After that we print the value of <code class=\"language-text\">r</code>.</p>\n<p>However, we‚Äôll quickly learn that the compiler isn‚Äôt really happy about this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `x` does not live long enough\n --&gt; src/main.rs:6:13\n  |\n6 |         r = &amp;x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |     println!(&quot;{}&quot;, r)\n  |                    - borrow later used here</code></pre></div>\n<p>This makes sense. We‚Äôre printing the value of <code class=\"language-text\">r</code> which holds a reference to <code class=\"language-text\">x</code>, but <code class=\"language-text\">x</code> is dropped from memory before that. In other words, <code class=\"language-text\">r</code> outlives <code class=\"language-text\">x</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>  ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì<span class=\"token operator\">+</span>\n    <span class=\"token punctuation\">{</span>       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì<span class=\"token operator\">+</span> <span class=\"token operator\">|</span>\n        <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>       <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>‚Äì‚Äì‚Äì <span class=\"token comment\">// Lifetime of `&amp;x`</span>\n        r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>          <span class=\"token operator\">|</span> <span class=\"token operator\">|</span>\n    <span class=\"token punctuation\">}</span>       ‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì‚Äì<span class=\"token operator\">+</span> <span class=\"token operator\">|</span> <span class=\"token operator\">&lt;</span>‚Äì‚Äì‚Äì <span class=\"token comment\">// Lifetime of `r`</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> ‚Äì‚Äì‚Äì‚Äì‚Äì<span class=\"token operator\">+</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In other words, if the reference doesn‚Äôt live at least as long as the variable does, <code class=\"language-text\">r</code> will be a dangling pointer at some point.</p>\n<p>This might feel like an annoying characteristic of the Rust compiler, but it‚Äôs actually an extremely powerful feature. Let this sink in for a second: <strong>The compiler is able to derive from your code if and where you‚Äôre trying to access a variable that potentially points to nothing.</strong> ü§Ø</p>\n<p>To make the code above work, we obviously have to move <code class=\"language-text\">x</code> in a way that its lifetime encloses the one of <code class=\"language-text\">r</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Sweet. We understand the concept of lifetimes now, but we still don‚Äôt know when and why we need to apply this weird syntax (<code class=\"language-text\">&lt;&#39;a&gt;</code>) from earlier. Let‚Äôs dig into that by looking at lifetimes and function arguments.</p>\n<h2>Lifetimes and Arguments</h2>\n<p>Given what we‚Äôve learned so far, we might wonder how these concepts apply to functions that take references as arguments. You might have already guessed that there‚Äôs no magic mechanism that removes the idea of lifetimes in Rust, just because a reference is passed to a function. Let‚Äôs take a look at the function below, which takes any argument that‚Äôs of type <code class=\"language-text\">&amp;i32</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">some_function</span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>What we don‚Äôt see here, is that Rust actually expands this code as if it was written like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> some_function<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Look, there‚Äôs the <code class=\"language-text\">&lt;&#39;a&gt;</code> again! What‚Äôs going on here? We‚Äôve just written out explicitly what Rust allows us to omit. <code class=\"language-text\">&#39;a</code> is a <strong>lifetime parameter</strong> of our <code class=\"language-text\">some_function</code>. It doesn‚Äôt really matter at this point that we call it <code class=\"language-text\">&#39;a</code>, we might as well call it <code class=\"language-text\">&#39;foo</code> or <code class=\"language-text\">&#39;lifetime</code>, however it‚Äôs convenient to give it some name that is enumerable (like the alphabet), because there could be more than one lifetime parameter, but more on that later. <strong>Keep in mind however, that lifetimes are a compile-time feature and don‚Äôt exist at runtime</strong>.</p>\n<p>With this signature we‚Äôre basically saying: <code class=\"language-text\">some_function</code> takes a reference to an <code class=\"language-text\">i32</code> with any given lifetime <code class=\"language-text\">&#39;a</code>. This is enough information for the compiler to know that <code class=\"language-text\">some_function</code> won‚Äôt save <code class=\"language-text\">val</code> anywhere that might outlife the call. It would be different if <code class=\"language-text\">some_function</code> took a lifetime parameter of <code class=\"language-text\">&#39;static</code>, which is Rust‚Äôs lifetime for anything that is considered global. In such a case, whatever is passed to the function, needs to live at least as long. By definition, only `static values would match that constraint.</p>\n<p>The same applies to functions that return references as well!</p>\n<h2>Returning References</h2>\n<p>Fairly often, functions take references to data structures and return a reference that points <strong>into</strong> that structure. The following function illustrates this case:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">smallest_number</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span>i32 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> s <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> r <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> r <span class=\"token operator\">&lt;</span> s <span class=\"token punctuation\">{</span>\n            s <span class=\"token operator\">=</span> r<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    s\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">smallet_number</code> takes a reference to a vector of numbers and returns a reference to a number. By default, Rust will assume that these two references have the same lifetime. So the function signature will be expanded to:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> smallest_number<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> <span class=\"token punctuation\">[</span>i32<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32 <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again, we‚Äôre basically saying: For any lifetime <code class=\"language-text\">&#39;a</code>, <code class=\"language-text\">smallest_number</code> takes a <code class=\"language-text\">&amp;[i32]</code> and returns a <code class=\"language-text\">&amp;i32</code> that has the same lifetime. This ensures that we can‚Äôt borrow the returned reference from <code class=\"language-text\">smallest_number</code> if it doesn‚Äôt life at least as long as the variable we‚Äôve assigned it to. In other words, if we try to compile the this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    s <span class=\"token operator\">=</span> <span class=\"token function\">smallest_number</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Rust will tell us that <code class=\"language-text\">numbers</code> doesn‚Äôt live long enough:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `numbers` does not live long enough\n --&gt; src/main.rs:5:29\n  |\n5 |         s = smallest_number(&amp;numbers);\n  |                             ^^^^^^^^ borrowed value does not live long enough\n6 |     }\n  |     - `numbers` dropped here while still borrowed\n7 |     println!(&quot;{}&quot;, s)\n  |                    - borrow later used here</code></pre></div>\n<p>Coming back to the scenario we started out with, namely structs that contain references, things make much more sense now.</p>\n<h2>Structs with references</h2>\n<p>When it comes to actual type definitions, like the ones we‚Äôve started out with in this article, as soon as it contains references, we have to write out their lifetimes. The code below won‚Äôt compile.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>While this one does:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Config <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    config<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Config\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You might be wondering: Why can‚Äôt the compiler simply expand our types with lifetimes just like it does with functions?</p>\n<p>Good question! Turns out, earlier versions of the compiler actually did exactly that. However, developers found that part confusing and preferred it to know exactly when one value borrows something from another.</p>\n<p>One last thing to note here, if <code class=\"language-text\">App</code> was borrowed in another type, that type will have to define its lifetime parameters as well:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Platform<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    app<span class=\"token punctuation\">:</span> App<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Lifetime parameters of different lifetimes</h2>\n<p>Of course, it‚Äôs also possible for functions and types to contain references of <strong>different</strong> lifetimes. Say we have a struct <code class=\"language-text\">Point</code> that takes <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> which are both <code class=\"language-text\">&amp;i32</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We‚Äôve already learned that we have to write out the lifetimes of the references, so we could go ahead and define them like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That‚Äôs fine, as long as <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> have indeed the same lifetime. For example, the following code would compile:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">let</span> point <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However, as soon as <code class=\"language-text\">x</code> and <code class=\"language-text\">y</code> have different lifetimes and we‚Äôre trying to reference one of them outside of the smallest scope, things are not going to fly.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> r<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> y <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> point <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>y <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        r <span class=\"token operator\">=</span> point<span class=\"token punctuation\">.</span>x\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Rust will have to find a lifetime that works for <code class=\"language-text\">point.x</code> and <code class=\"language-text\">point.y</code> but also <strong>encloses</strong> <code class=\"language-text\">r</code>‚Äôs lifetime. Since this code doesn‚Äôt satisfy that constraint we‚Äôll get a compile error:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0597]: `y` does not live long enough\n  --&gt; src/main.rs:12:39\n   |\n12 |         let point = Point { x: &amp;x, y: &amp;y };\n   |                                       ^^ borrowed value does not live long enough\n13 |         r = point.x\n14 |     }\n   |     - `y` dropped here while still borrowed\n15 |     println!(&quot;{}&quot;, r);\n   |                    - borrow later used here</code></pre></div>\n<p>To get around this, we can simply say that <code class=\"language-text\">Point</code> has multiple distinct lifetime parameters by extending the type definition like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Point<span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a,</span> <span class=\"token lifetime-annotation symbol\">'b</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    x<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> i32<span class=\"token punctuation\">,</span>\n    y<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'b</span> i32\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>Alright, so we‚Äôve talked about the fact that Rust keeps its references under control by assigning lifetimes to them. Lifetimes are a compile-time only feature and don‚Äôt exist at runtime. They ensure that types containing references don‚Äôt outlive their them, which basically prevents us from writing code that produces dangling poitners. We also learned that in many cases, lifetime definitions can be omitted and Rust fills in the gaps for us. It‚Äôs also possible to have types with multiple distinct lifetime parameters.</p>\n<p>I hope this article gave you a better idea of what lifetimes are, how they work and when and why they are needed.</p>","frontmatter":{"author":"pascal_precht","title":"Lifetimes in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABVdsxnCg//8QAGxAAAwACAwAAAAAAAAAAAAAAAQIDABEEEyL/2gAIAQEAAQUCSYefTrHHvjjU6uyjP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAABAh/9oACAECAQE/Aaf/xAAbEAACAwADAAAAAAAAAAAAAAABAgAQERIhMf/aAAgBAQAGPwLir4wmMSYfK6Nf/8QAGhABAQEBAAMAAAAAAAAAAAAAAREAMRAhsf/aAAgBAQABPyGiCq0wkIPrrQgvqYhTr3AGHfH/2gAMAwEAAgADAAAAELQv/8QAFREBAQAAAAAAAAAAAAAAAAAAAQD/2gAIAQMBAT8QAkv/xAAXEQEAAwAAAAAAAAAAAAAAAAABEBEx/9oACAECAQE/EFtsf//EABoQAQEBAQEBAQAAAAAAAAAAAAERACFhMUH/2gAIAQEAAT8QqQE07fk81oOgVkKzwwUwoAhzmIed1+usKMWGd//Z","aspectRatio":1.7794253938832252,"src":"/static/7d645708f8d10881ad143fcda83a259c/30037/lifetimes.jpg","srcSet":"/static/7d645708f8d10881ad143fcda83a259c/10bdc/lifetimes.jpg 158w,\n/static/7d645708f8d10881ad143fcda83a259c/f4ab0/lifetimes.jpg 315w,\n/static/7d645708f8d10881ad143fcda83a259c/30037/lifetimes.jpg 630w,\n/static/7d645708f8d10881ad143fcda83a259c/9810d/lifetimes.jpg 945w,\n/static/7d645708f8d10881ad143fcda83a259c/ff2e4/lifetimes.jpg 1260w,\n/static/7d645708f8d10881ad143fcda83a259c/14dee/lifetimes.jpg 1920w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"20 October 2020","summary":"Learn what Lifetimes are, why they exist and when you need them. This and more we'll explore in this article.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/lifetimes-in-rust/","previous":{"fields":{"slug":"/iterators-in-rust/"},"frontmatter":{"date":"2020/10/08","title":"Iterators in Rust","categories":["rust"]}},"next":{"fields":{"slug":"/announcements/2024/02/13/farewell.html"},"frontmatter":{"date":"2024/02/13","title":"Farewell","categories":["announcements"]}}}}}
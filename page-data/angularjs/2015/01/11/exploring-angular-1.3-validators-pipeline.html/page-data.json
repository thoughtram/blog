{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2015/01/11/exploring-angular-1.3-validators-pipeline.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"082d6740-9cea-569c-a01f-3772318e5e28","excerpt":"We know that working with forms in Angular is just great. Due to its scope model nature, we always have a reference to the actual form state in its…","html":"<p>We know that working with forms in Angular is just great. Due to its scope model nature, we always have a reference to the actual form state in its corresponding scope, which makes it easy to access particular field values or represent the form state in our views.</p>\n<p>If there’s one thing that takes probably most of the work when building forms, it’s their validation. We know that validation on the server-side is always required in order to process given user data that could break our app. But we also want to provide a great user experience, which is where validation on the client-side comes into play. We already learned about <a href=\"http://blog.thoughtram.io/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html\">ngModelOptions</a>. In this article we are going to discuss the ways we’ve been able to validate data in our Angular forms in 1.2 and detail how version 1.3 makes it even easier with the validators pipeline.</p>\n<h2>Built-in form validation</h2>\n<p>Before we start looking at what the latest bigger Angular release brings to the table when it comes to form validation, let’s take a look at what capabilities we had anyway and also especially, why there was a need for an improvement at all.</p>\n<p>HTML5 provides some validation attributes we can use to let the browser validate our form controls. For example, if we want to have native validation support for email input fields, all we have to do is to apply the <code class=\"language-text\">required</code> attribute to that element.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input type=&quot;email&quot; required&gt;</code></pre></div>\n<p>And as you probably know, there are a couple of other validation attributes like <code class=\"language-text\">minlength</code>, <code class=\"language-text\">maxlength</code> and <code class=\"language-text\">pattern</code>. However, it turns out that the API is inconsistent and not even supported in all browsers and platforms today. That’s why Angular provides basic implementation for HTML5 validation with its <code class=\"language-text\">ngModel</code> directive and controller and makes it consistent between browsers.</p>\n<p>Here’s a list of supported validation attributes:</p>\n<ul>\n<li><code class=\"language-text\">ng-required</code></li>\n<li><code class=\"language-text\">ng-minlength</code></li>\n<li><code class=\"language-text\">ng-maxlength</code></li>\n<li><code class=\"language-text\">ng-min</code></li>\n<li><code class=\"language-text\">ng-max</code></li>\n<li><code class=\"language-text\">ng-pattern</code></li>\n</ul>\n<p>In addition to that, Angular validates certain input types automatically without us doing anything. The following code displays a simple form that has just one field of type <code class=\"language-text\">email</code>. Applying an <code class=\"language-text\">ng-model</code> to it makes Angular aware of it. Also notice the <code class=\"language-text\">name</code> attribute of the form which publishes the <code class=\"language-text\">FormController</code> instance of the form into the scope.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;form name=&quot;myForm&quot;&gt;\n  &lt;input type=&quot;email&quot; name=&quot;emailField&quot;&gt;\n  &lt;p ng-if=&quot;myForm.emailField.$error.email&quot;&gt;Email address is not valid!&lt;/p&gt;\n&lt;/form&gt;</code></pre></div>\n<p>Running this code in the browser, you can see the validation happens automatically. Errors are even exposed on the <code class=\"language-text\">FormController</code>’s <code class=\"language-text\">$error</code> object, which makes displaying error messages a breeze.</p>\n<p>Of course, <code class=\"language-text\">email</code> is not the only type where automatic validation happens. It’s also triggered when type <code class=\"language-text\">url</code> or <code class=\"language-text\">number</code> is used. In 1.3 there’s additional support for date and time inputs like <code class=\"language-text\">date</code>, <code class=\"language-text\">time</code>, <code class=\"language-text\">datetime-local</code>, <code class=\"language-text\">week</code> and <code class=\"language-text\">month</code> as well.</p>\n<h2>Custom Validations - The Old Way</h2>\n<p>Built-in validations are nice, but in some cases we need validations that go far beyond the basic functionality we get out of the box. And this is where custom validations come in.</p>\n<p>The key part of validation in Angular is the <code class=\"language-text\">ngModelController</code> since it controls the logic of passing values back and forth between the DOM and the scope. In versions before 1.3, we were able to implement custom validations by using <code class=\"language-text\">ngModelController</code> and it’s <code class=\"language-text\">$formatters</code> and <code class=\"language-text\">$parsers</code> pipeline.</p>\n<p>Let’s say we want to implement a custom validation that checks if the value that is passed by the user is an actual integer. In order to do that, we would first create a new directive that accesses <code class=\"language-text\">ngModelController</code> like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;validateInteger&#39;, function () {\n  return {\n    require: &#39;ngModel&#39;,\n    link: function (scope, element, attrs, ctrl) {\n      // add validation to ctrl\n    }\n  };\n});</code></pre></div>\n<p>In a directive’s <code class=\"language-text\">link</code> function, we can ask for other directives controllers with the <code class=\"language-text\">require</code> property of the directive definition object. <code class=\"language-text\">ctrl</code> is now a reference to an <code class=\"language-text\">ngModelController</code> instance which has a <code class=\"language-text\">$formatters</code> and <code class=\"language-text\">$parsers</code> property. These two properties are arrays, that act as pipelines that get called when certain things happen.</p>\n<p>These certain things are:</p>\n<ul>\n<li><strong>Model to view update</strong> - Whenever the bound model changes, all functions in <code class=\"language-text\">$formatters</code> are called one by one, in order to format the value and changes it’s validity state.</li>\n<li><strong>View to model update</strong> - Whenever the user interacts with a form control, it calls the <code class=\"language-text\">ngModelController</code>’s <code class=\"language-text\">$setViewValue</code> method, which in turn calls all functions of the <code class=\"language-text\">$parsers</code> array in order to convert the value and also change it’s validity state accordingly.</li>\n</ul>\n<p>Okay, so we have one pipeline that pipes the value from model to view and another one that pipes it from view to model. Since we want to check if the given value in our control is an actual integer, we need to use the pipeline that is executed when the view updates the model, which is the <code class=\"language-text\">$parsers</code> array.</p>\n<p>All we have to do now, is to add a new function to <code class=\"language-text\">$parsers</code> that performs the needed checks and sets the validity state with <code class=\"language-text\">$setValidity()</code> accordingly. In order to make sure that our validation function is called first in the pipe, we use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift\">Array.prototype.unshift</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;validateInteger&#39;, function () {\n\n  var REGEX = /^\\-?\\d+$/;\n\n  return {\n    require: &#39;ngModel&#39;,\n    link: function (scope, element, attrs, ctrl) {\n\n      ctrl.$parsers.unshift(function (viewValue) {\n\n        if (REGEX.test(viewValue)) {\n          ctrl.$setValidity(&#39;integer&#39;, true);\n          return viewValue;\n        } else {\n          ctrl.$setValidity(&#39;integer&#39;, false);\n          // if invalid, return undefined\n          // (no model update happens)\n          return undefined;\n        }\n\n      });\n    }\n  };\n});</code></pre></div>\n<p>We check if the new values matches against our regular expression. If it matches we set the validity of <code class=\"language-text\">integer</code> to <code class=\"language-text\">true</code> and return <code class=\"language-text\">viewValue</code>, so it can be passed to further parser functions.</p>\n<p>In case it doesn’t match, we set it’s validity to <code class=\"language-text\">false</code>, which also exposes an <code class=\"language-text\">integer</code> member on the <code class=\"language-text\">FormController</code>’s <code class=\"language-text\">$error</code> object, so we can display error messages accordingly. We also return <code class=\"language-text\">undefined</code> explicitly, in order to stop processing of the pipe.</p>\n<p>We can then use it like every other directive:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;form name=&quot;myForm&quot;&gt;\n  &lt;input type=&quot;text&quot; validate-integer&gt;\n  &lt;p ng-if=&quot;myForm.$error.integer&quot;&gt;Oups error.&lt;/p&gt;\n&lt;/form&gt;</code></pre></div>\n<p>As you can see, there’s a lot to take care of when writing custom validations. We need to know about the <code class=\"language-text\">$parsers</code> and <code class=\"language-text\">$formatters</code> pipeline. We also need to set a value’s validity state explicitly with <code class=\"language-text\">$setValidity()</code>.</p>\n<p>In addition to that, it turns out that due to the nature of HTML5 form validation, some input types may not expose the input value until the valid value is entered.</p>\n<p>So how does Angular 1.3 a better job?</p>\n<h2>Meet the <code class=\"language-text\">$validators</code> pipeline</h2>\n<p>Angular 1.3 introduces yet another pipeline, the <code class=\"language-text\">$validators</code> pipeline, which is rather used than <code class=\"language-text\">$parsers</code> + <code class=\"language-text\">$formatters</code>. Unlike parsers and formatters, the validators pipeline has access to both, <code class=\"language-text\">viewValue</code> and <code class=\"language-text\">modelValue</code>, since it’s called once <code class=\"language-text\">$parsers</code> and <code class=\"language-text\">$formatters</code> has been successfully run.</p>\n<p>Another API difference is that <code class=\"language-text\">$validators</code> is not an array, but an object with each member describing a validator. Let’s implement our <code class=\"language-text\">integer</code> custom validation as part of the <code class=\"language-text\">$validators</code> pipeline.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;validateInteger&#39;, function () {\n\n  var REGEX = /^\\-?\\d+$/;\n\n  return {\n    require: &#39;ngModel&#39;,\n    link: function (scope, element, attrs, ctrl) {\n\n      ctrl.$validators.integer = function (modelValue, viewValue) {\n\n        if (REGEX.test(viewValue)) {\n          return true\n        }\n        return false;\n      };\n    }\n  };\n});</code></pre></div>\n<p>As you can see, we no longer have to take care of calling <code class=\"language-text\">$setValidity()</code>. Angular calls <code class=\"language-text\">$setValidity()</code> internally, with the value that a validator returns, which is either <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code>.</p>\n<p>And of course, if a value is invalid, an <code class=\"language-text\">$error</code> is exposed on the <code class=\"language-text\">FormController</code> accordingly.</p>\n<h2>Async validators</h2>\n<p>With 1.3, Angular goes even a step futher and makes asynchronous validations possible. Just imagine the case you have an input field for a user name and whenever a user types in a name, you need to perform some validity checks on your server. The application needs to wait until the server responses.</p>\n<p>That’s why there’s next to <code class=\"language-text\">$validators</code> <strong>another</strong> validators object called <code class=\"language-text\">$asyncValidators</code>. Asynchronous validators work pretty much like synchronous validators except that they are asynchronous and therefore promise based. Instead of returning <code class=\"language-text\">true</code> or <code class=\"language-text\">false</code>, we return a promise that holds the state of an asynchronous code execution.</p>\n<p>Here’s what it could look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;validateUsername&#39;, function ($q, userService) {\n\n  return {\n    require: &#39;ngModel&#39;,\n    link: function (scope, element, attrs, ctrl) {\n\n      ctrl.$asyncValidators.username = function (modelValue, viewValue) {\n        return $q(function (resolve, reject) {\n          userService.checkValidity(viewValue).then(function () {\n              resolve();\n            }, function () {\n              reject();\n            });\n        });\n      };\n    }\n  };\n});</code></pre></div>\n<p>Asynchronous validators are called, after synchronous validators have been successfully executed. While an asynchronous validator is running, a <code class=\"language-text\">$pending</code> object will be exposed on the field’s <code class=\"language-text\">ngModelController</code>. Flags like <code class=\"language-text\">$valid</code> and <code class=\"language-text\">$invalid</code> are set to <code class=\"language-text\">undefined</code> at this point.</p>\n<p>We could display a loading message like this (notice the <code class=\"language-text\">name</code> attribute applied to the field to expose it’s controller):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;form name=&quot;myForm&quot;&gt;\n  &lt;input type=&quot;text&quot; name=&quot;username&quot; validate-username&gt;\n  &lt;p ng-if=&quot;myForm.username.$pending&quot;&gt;Validating user name...&lt;/p&gt;\n&lt;/form&gt;</code></pre></div>\n<p>Okay, we now learned about <code class=\"language-text\">$validators</code> and <code class=\"language-text\">$asynchValidators</code>, but does that mean our existing <code class=\"language-text\">$parsers</code> and <code class=\"language-text\">$formatters</code> won’t work anymore?</p>\n<p>The answer is <strong>no</strong>. The validation pipeline has been added to the existing pipelines. It is basically there, so developers can explicitly distinguish between validations and parsing/formatting related functionality.</p>\n<p>Also, as we learned, the validators pipeline has a slight simpler API. We don’t have to take care of setting <code class=\"language-text\">$setValidity()</code> anymore. And we can finally do proper asynchronous validations.</p>","frontmatter":{"author":"pascal_precht","title":"Validators Pipeline in Angular 1.3","imageUrl":null,"date":"11 January 2015","summary":"In this article we discuss a newly introduced feature called custom validators, so we don't have to hijack parsers and formatters anymore.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2015/01/11/exploring-angular-1.3-validators-pipeline.html","previous":{"fields":{"slug":"/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html"},"frontmatter":{"date":"2015/01/02","title":"Binding to Directive Controllers in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2015/01/14/exploring-angular-1.3-speed-up-with-applyAsync.html"},"frontmatter":{"date":"2015/01/14","title":"Go fast with $applyAsync in Angular 1.3","categories":["angularjs"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"57829cb4-8fd1-5c56-8180-021651474c72","excerpt":"In version 1.2, Angular introduced a new  syntax that made scoping clearer and controllers smarter. In fact, it’s a best practice to use  throughout our Angular…","html":"<p>In version 1.2, Angular introduced a new <code class=\"language-text\">controllerAs</code> syntax that made scoping clearer and controllers smarter. In fact, it’s a best practice to use <code class=\"language-text\">controllerAs</code> throughout our Angular apps in order to prevent some common problems that developers run into fairly often.</p>\n<p>Even if it’s nice that we are able to use that syntax in pretty much every case where a controller comes into play, it turned out that in version 1.2, there’s a little quirk when using it with directives that have an isolated scope. But before we get to the actual problem, let’s recap <code class=\"language-text\">controllerAs</code> in general first, to get an idea of what problems it solves and how to use it, so that we are all on the same page.</p>\n<h2><code class=\"language-text\">controllerAs</code> as Namespace</h2>\n<p>Who of us did not run into the problem that, when having nested scopes created by nested controllers, scope properties that have the same name as properties on the parent scope, shadow that value of the parent scope property due to JavaScript’s prototypical inheritance model?</p>\n<p>Or, when speaking in code, having two controllers like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function ControllerOne($scope) {\n  $scope.foo = &#39;Pascal&#39;;\n}\n\nfunction ControllerTwo($scope) {\n  $scope.foo = &#39;Christoph&#39;;\n}\n\napp.controller(&#39;ControllerOne&#39;, ControllerOne);\napp.controller(&#39;ControllerTwo&#39;, ControllerTwo);</code></pre></div>\n<p>And a DOM structure like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div ng-controller=&quot;ControllerOne&quot;&gt;\n  {{foo}}\n  &lt;div ng-controller=&quot;ControllerTwo&quot;&gt;\n    {{foo}}\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>The {% raw %} <code class=\"language-text\">{{foo}}</code> {% endraw %} expression in <code class=\"language-text\">ControllerTwo</code> scope will shadow the {% raw %} <code class=\"language-text\">{{foo}}</code> {% endraw %} expression in <code class=\"language-text\">ControllerOne</code> scope, which results in string <code class=\"language-text\">Christoph</code> being displayed in the inner scope and <code class=\"language-text\">Pascal</code> being displayed in the outer scope.</p>\n<p>We could always get around this problem by using a scope’s <code class=\"language-text\">$parent</code> property to reference its parent scope when accessing scope properties like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div ng-controller=&quot;ControllerOne&quot;&gt;\n  {{foo}}\n  &lt;div ng-controller=&quot;ControllerTwo&quot;&gt;\n    {{$parent.foo}}\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>However, it turns out that using <code class=\"language-text\">$parent</code> is actually a bad practice, since we start coupling our expression code to the underlying DOM structure, which makes our code less maintainable. Just imagine you have not only two nested scopes, but four or five. That would bring you into <code class=\"language-text\">$parent.$parent.$parent.$parent</code> hell, right?</p>\n<p>That’s one of the reasons why you might have heard that we should <strong>always</strong> have a dot in our expressions that access scope properties. In other words, this could easily be fixed with doing the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function ControllerOne($scope) {\n  $scope.modelOne = {\n    foo: &#39;Pascal&#39;\n  };\n}\n\nfunction ControllerTwo($scope) {\n  $scope.modelTwo = {\n    foo: &#39;Christoph&#39;\n  };\n}</code></pre></div>\n<p>And in our template, we update our expressions accordingly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div ng-controller=&quot;ControllerOne&quot;&gt;\n  {{modelOne.foo}}\n  &lt;div ng-controller=&quot;ControllerTwo&quot;&gt;\n    {{modelOne.foo}}\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>And here comes <code class=\"language-text\">controllerAs</code> into play. This syntax allows us to introduce a new namespace bound to our controller without the need to put scope properties in an additional object literal. In fact, we don’t even need to request <code class=\"language-text\">$scope</code> in our controller anymore, since the scope is bound the controller’s <code class=\"language-text\">this</code> reference when using <code class=\"language-text\">controllerAs</code>.</p>\n<p>Let’s see what that looks like in code. First we remove the <code class=\"language-text\">$scope</code> service and assign our values to <code class=\"language-text\">this</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function ControllerOne() {\n  this.foo = &#39;Pascal&#39;;\n}\n\nfunction ControllerTwo() {\n  this.foo = &#39;Christoph&#39;;\n}</code></pre></div>\n<p>Next, we update <code class=\"language-text\">ngController</code> directive expression with the <code class=\"language-text\">controllerAs</code> syntax, and use the new namespaces in our scopes:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;div ng-controller=&quot;ControllerOne as ctrl1&quot;&gt;\n  {{ctrl1.foo}}\n  &lt;div ng-controller=&quot;ControllerTwo as ctrl2&quot;&gt;\n    {{ctrl2.foo}}\n  &lt;/div&gt;\n&lt;/div&gt;</code></pre></div>\n<p>It gets even better. We are able to use that syntax whenever a controller is used. For example if we configure an application state with Angular’s <code class=\"language-text\">$routeProvider</code> we can use <code class=\"language-text\">controllerAs</code> there too, in order to make our template code more readable.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$routeProvider.when(&#39;/&#39;, {\n  templateUrl: &#39;stateTemplate.html&#39;,\n  controllerAs: &#39;ctrl&#39;,\n  controller: &#39;StateController&#39;\n});</code></pre></div>\n<p>And as you probably know, directives can also have controllers and yes, we can use <code class=\"language-text\">controllerAs</code> there too.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.controller(&#39;SomeController&#39;, function () {\n  this.foo = &#39;bar&#39;;\n});\n\napp.directive(&#39;someDirective&#39;, function () {\n  return {\n    restrict: &#39;A&#39;,\n    controller: &#39;SomeController&#39;,\n    controllerAs: &#39;ctrl&#39;,\n    template: &#39;{{ctrl.foo}}&#39;\n  };\n});</code></pre></div>\n<p>Great. Now we know what the <code class=\"language-text\">controllerAs</code> syntax it is all about, but we haven’t talked about the little drawback that it comes with in 1.2. Let’s move on with that one.</p>\n<h2>The problem with <code class=\"language-text\">controllerAs</code> in Directives</h2>\n<p>We said that, when using <code class=\"language-text\">controllerAs</code>, the controllers’ scope is bound to the controllers’ <code class=\"language-text\">this</code> object, so in other words - <code class=\"language-text\">this</code> represents our scope. But how does that work when building a directive with isolated scope?</p>\n<p>We know we can create an isolated scope by adding an object literal to our directive definition object that defines how each scope property is bound to our directive. To refresh our memory, here’s what we can do:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {\n      oneWay: &#39;@&#39;,\n      twoWay: &#39;=&#39;,\n      expr: &#39;&amp;&#39;\n    }\n  };\n});</code></pre></div>\n<p>This is a directive with an isolated scope that defines how its scope properties are bound. Alright, let’s say we have directive with an isolated scope, a controller and a template that uses the controller properties accordingly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {},\n    controller: function () {\n      this.name = &#39;Pascal&#39;\n    },\n    controllerAs: &#39;ctrl&#39;,\n    template: &#39;&lt;div&gt;{{ctrl.name}}&lt;/div&gt;&#39;\n  };\n});</code></pre></div>\n<p>Easy. That works and we knew that already. Now to the tricky part: what if <code class=\"language-text\">name</code> should be two-way bound?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {\n      name: &#39;=&#39;\n    },\n    // ...\n  };\n});</code></pre></div>\n<p>Changes to isolated scope properties from the outside world are not reflected back to the controllers’ <code class=\"language-text\">this</code> object. What we need to do to make this work in 1.2, is to use the <code class=\"language-text\">$scope</code> service to re-assign our scope values explicitly, whenever a change happens on a particular property. And of course, we mustn’t forget to bind our watch callback to the controllers’ <code class=\"language-text\">this</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {\n      name: &#39;=&#39;\n    },\n    controller: function ($scope) {\n      this.name = &#39;Pascal&#39;;\n\n      $scope.$watch(&#39;name&#39;, function (newValue) {\n        this.name = newValue;\n      }.bind(this));\n    },\n    // ...\n  };\n});</code></pre></div>\n<p>Here we go… the <code class=\"language-text\">$scope</code> service we initially got rid off is now back. If you now think this is crazy, especially when considering that this is just one scope property and in a real world directive you usually have more than one, then my friend, I agree with you.</p>\n<p>Luckily, this is no longer a problem in Angular 1.3!</p>\n<h2>Binding to controllers with <code class=\"language-text\">bindToController</code></h2>\n<p>Angular 1.3 introduces a new property to the directive definition object called <code class=\"language-text\">bindToController</code>, which does exactly what it says. When set to <code class=\"language-text\">true</code> in a directive with isolated scope that uses <code class=\"language-text\">controllerAs</code>, the component’s properties are bound to the controller rather than to the scope.</p>\n<p>That means, Angular makes sure that, when the controller is instantiated, the initial values of the isolated scope bindings are available on <code class=\"language-text\">this</code>, and future changes are also automatically available.</p>\n<p>Let’s apply <code class=\"language-text\">bindToController</code> to our directive and see how the code becomes cleaner.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {\n      name: &#39;=&#39;\n    },\n    controller: function () {\n      this.name = &#39;Pascal&#39;;\n    },\n    controllerAs: &#39;ctrl&#39;,\n    bindToController: true,\n    template: &#39;&lt;div&gt;{{ctrl.name}}&lt;/div&gt;&#39;\n  };\n});</code></pre></div>\n<p>As we can see, we don’t need <code class=\"language-text\">$scope</code> anymore (yay!) and there’s also no <code class=\"language-text\">link</code> nor <code class=\"language-text\">compile</code> function in this directive definition. At the same time we keep taking advantage of <code class=\"language-text\">controllerAs</code>.</p>\n<h2>Improvements in 1.4</h2>\n<p>In version <code class=\"language-text\">1.4</code>, <code class=\"language-text\">bindToController</code> gets even more powerful. When having an isolated scope with properties to be bound to a controller, we always define those properties on the scope definition and <code class=\"language-text\">bindToController</code> is set to <code class=\"language-text\">true</code>. In <code class=\"language-text\">1.4</code> however, we can move all our property binding definitions to <code class=\"language-text\">bindToController</code> and make it an object literal.</p>\n<p>Here’s an example with a component directive that uses <code class=\"language-text\">bindToController</code>. Instead of defining the scope properties on <code class=\"language-text\">scope</code>, we declaratively define what properties are bound to the component’s controller:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: {},\n    bindToController: {\n      someObject: &#39;=&#39;,\n      someString: &#39;@&#39;,\n      someExpr: &#39;&amp;&#39;\n    }\n    controller: function () {\n      this.name = &#39;Pascal&#39;;\n    },\n    controllerAs: &#39;ctrl&#39;,\n    template: &#39;&lt;div&gt;{{ctrl.name}}&lt;/div&gt;&#39;\n  };\n});</code></pre></div>\n<p>In addition to that, <code class=\"language-text\">bindToController</code> is no longer exclusive to isolated scope directives! Whenever we build a directive that introduces a new scope, we can take advantage of <code class=\"language-text\">bindToController</code>. So the following code also works:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;someDirective&#39;, function () {\n  return {\n    scope: true\n    bindToController: {\n      someObject: &#39;=&#39;,\n      someString: &#39;@&#39;,\n      someExpr: &#39;&amp;&#39;\n    },\n    ...\n  };\n});</code></pre></div>","frontmatter":{"author":"pascal_precht","title":"Binding to Directive Controllers in Angular 1.3","imageUrl":null,"date":"02 January 2015","summary":"In this article we are going to take a look how to bind values to directive controllers to make them more reusable.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html","previous":{"fields":{"slug":"/angularjs/2014/12/22/exploring-angular-1.3-disabling-debug-info.html"},"frontmatter":{"date":"2014/12/22","title":"Disabling Debug Info in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2015/01/11/exploring-angular-1.3-validators-pipeline.html"},"frontmatter":{"date":"2015/01/11","title":"Validators Pipeline in Angular 1.3","categories":["angularjs"]}}}}}
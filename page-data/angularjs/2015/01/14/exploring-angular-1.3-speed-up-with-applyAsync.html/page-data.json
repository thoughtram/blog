{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2015/01/14/exploring-angular-1.3-speed-up-with-applyAsync.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"bb7ecc93-9893-50ca-9eaf-c4521eda1840","excerpt":"As already mentioned in our articles on one-time bindings and disabling debug info, one of the biggest goals of the 1.3 release was to improve Angular’s overall…","html":"<p>As already mentioned in our articles on <a href=\"http://blog.thoughtram.io/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html\">one-time bindings</a> and <a href=\"http://blog.thoughtram.io/angularjs/2014/12/22/exploring-angular-1.3-disabling-debug-info.html\">disabling debug info</a>, one of the biggest goals of the 1.3 release was to improve Angular’s overall performance.</p>\n<p>This article details yet another nice feature that makes your Angular applications in particular cases potentially faster: It lets you resolve multiple <code class=\"language-text\">$http</code> responses, that are received around the same time, in one <code class=\"language-text\">$digest</code> cycle with a new API added to the <code class=\"language-text\">$rootScope</code> called <code class=\"language-text\">$applyAsync</code>.</p>\n<p>Let’s talk about what that actually means and why you want to do that.</p>\n<h2>Why and when we need the <code class=\"language-text\">$digest</code> cycle</h2>\n<p>We know that two-way data binding is one big selling point of Angular. Changes to our model in the imperative world of JavaScript seem to sync magically with the model values in the declarative world of HTML and vice versa, without us setting up any event listener and other things that are required to achieve that functionality.</p>\n<p>In fact, two-way binding is just one kind of binding that Angular supports. We also have one-way bindings and even one-time bindings (since version 1.3) as mentioned earlier. In order to make data binding possible, Angular comes with this sort of event loop (the <code class=\"language-text\">$digest</code>) to update our application model and DOM, whenever it is needed.</p>\n<p>But how does Angular know, when it has to trigger another <code class=\"language-text\">$digest</code> cycle? We don’t want to go in too much detail here, since there are ton of resources out there that cover this topic very well, but let’s clarify at least the most important facts. Some people think initially, that Angular has a kind of poll mechanism that checks every few milliseconds if something on the model changed so it can update the view accordingly. <strong>This is not true</strong>.</p>\n<p>There are basically three possible cases when the state of an application can change and these are the only moments where <code class=\"language-text\">$digest</code> cycles are needed. The case are:</p>\n<ul>\n<li><strong>User Interaction through events</strong> - The user clicks UI controls like buttons and in turn triggers something in our application that changes state.</li>\n<li><strong>XMLHttpRequests</strong> - Also known as AJAX. Something in our app requests some data from a server and update model data accordingly.</li>\n<li><strong>Timeouts</strong> - Asynchronous operations cause through timers that can possibly change the state of our application</li>\n</ul>\n<p>Whenever one of the above things happens, Angular knows it needs to trigger a <code class=\"language-text\">$digest</code>. You might still wonder how that works, since you don’t have to inform Angular about these interactions explicitly. This is because Angular intercepts all of these interactions already for you.</p>\n<p>That’s why we have all these predefined directives like <code class=\"language-text\">ng-click</code> or even directives that override existing tags like <code class=\"language-text\">&lt;input&gt;</code>. The <code class=\"language-text\">$http</code> service that Angular brings to the table also makes sure that a <code class=\"language-text\">$digest</code> is triggered once a request returns.</p>\n<p>In addtion, this explains why you need to call <code class=\"language-text\">$scope.$apply()</code>, which in turn triggers a <code class=\"language-text\">$digest</code> internally, when you have third-party code that changes your application’s state from the outside world.</p>\n<p>Okay, so now we have a general picture of what the <code class=\"language-text\">$digest</code> is about and when it’s needed and triggered and also how we can trigger it explicitly with <code class=\"language-text\">$scope.$apply</code>. But we haven’t talked about when <code class=\"language-text\">$applyAsync</code> comes into play.</p>\n<h2>Batching multiple <code class=\"language-text\">$http</code> responses into one <code class=\"language-text\">$digest</code></h2>\n<p>As the name already says, <code class=\"language-text\">$applyAsync</code> has something to do with executing a <code class=\"language-text\">$scope.$apply</code> through an asynchronous operation. But what does that mean and when makes it actually sense?</p>\n<p>We mentioned that one of the cases where a <code class=\"language-text\">$digest</code> is triggered, is when an XHR call using <code class=\"language-text\">$http</code> service returns from it’s execution. This is nice because we don’t have to worry about updating our model in the DOM once the model is updated. Here’s a small snippet that details that scenario (note that we don’t use <code class=\"language-text\">$scope</code> here since we assume that <a href=\"http://blog.thoughtram.io/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html\">controllerAs</a> syntax is used:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">controller</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Ctrl'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">$http</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">// Make XHR and update model accordingly</span>\n  $http<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fetch/some/json/'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>myModel <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We have a controller that asks for <code class=\"language-text\">$http</code> service and uses it to make an XHR to some url and once the call resolves, we update <code class=\"language-text\">myModel</code> on our controller with the new data that we got from the server. There’s nothing we need to do to update <code class=\"language-text\">myModel</code> in our DOM, since this call, once it resolves, triggers a <code class=\"language-text\">$digest</code> that takes care of the rest.</p>\n<p>Now imagine we build an application where it’s required to make <strong>three</strong> XHRs at bootstrap time. That means, three independent requests that all resolve independently after different periods of time, which in turn causes three <code class=\"language-text\">$digest</code> cycles that get triggered once each of the calls return. This can slow down our application. Wouldn’t it be nice if we could collect the promises that return from the XHR calls that are made around the same time and resolve them at the next <code class=\"language-text\">$digest</code> cycle that happens? Yes! And this is exactly where <code class=\"language-text\">$applyAsync</code> comes into play.</p>\n<p>Since Angular 1.3, <code class=\"language-text\">$rootScope</code> comes with a new method <a href=\"https://code.angularjs.org/1.3.8/docs/api/ng/type/$rootScope.Scope#$applyAsync\">$applyAsync</a> that lets us basically collect expressions. These expressions get immediately evaluated but resolved with the next tick (<code class=\"language-text\">$digest</code>). In order to make this work nice with requests that happen through <code class=\"language-text\">$http</code> calls, <code class=\"language-text\">$httpProvider</code> comes with a corresponding API that tells Angular that we actually want to use that feature.</p>\n<p>All we need to do is to call the provider’s <a href=\"https://code.angularjs.org/1.3.8/docs/api/ng/provider/$httpProvider#useApplyAsync\">useApplyAsync</a> method and Angular takes care of deferring the resolution of your XHR calls to the next tick. Here’s what it looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">config</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">$httpProvider</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  $httpProvider<span class=\"token punctuation\">.</span><span class=\"token function\">useApplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That’s it! If the application now receives multiple <code class=\"language-text\">$http</code> responses at around the same time, this is what happens (a bit simplified though):</p>\n<ul>\n<li>The call’s promise is pushed into a queue</li>\n<li>An asynchronous <code class=\"language-text\">$apply</code> is scheduled in case there’s no one scheduled yet, by telling the browser to execute <code class=\"language-text\">setTimeout()</code></li>\n<li>Once timed out, the queue is flushed and the actual <code class=\"language-text\">$apply</code> is triggered</li>\n</ul>\n<p>The <code class=\"language-text\">setTimeout()</code> is called with a <code class=\"language-text\">0</code> delay which causes an actual delay of around 10 milliseconds depending on the browser. That means, if our three asynchronous calls return at around the same time (somewhere inside that particular timeout delay), they get resolve with a single <code class=\"language-text\">$digest</code> cycle instead of three which speeds up our application.</p>","frontmatter":{"author":"pascal_precht","title":"Go fast with $applyAsync in Angular 1.3","imageUrl":null,"date":"14 January 2015","summary":"Angular 1.3 comes with a feature to share a running $digest cycle across multiple XHR calls. This articles details how to gain a nice performance boost.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2015/01/14/exploring-angular-1.3-speed-up-with-applyAsync.html","previous":{"fields":{"slug":"/angularjs/2015/01/11/exploring-angular-1.3-validators-pipeline.html"},"frontmatter":{"date":"2015/01/11","title":"Validators Pipeline in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2015/01/23/exploring-angular-1.3-ngMessages.html"},"frontmatter":{"date":"2015/01/23","title":"ngMessages in Angular 1.3","categories":["angularjs"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2014/12/18/exploring-angular-1.3-es6-style-promises.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"a77a20fe-63d8-5de1-9490-927c0a77b5dd","excerpt":"We mainly took a look at completely new features that come with the Angular 1.3 release until now. Things like ngModelOptions, Angular-hint or One-time Bindings…","html":"<p>We mainly took a look at completely new features that come with the Angular 1.3 release until now. Things like <a href=\"http://blog.thoughtram.io/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html\">ngModelOptions</a>, <a href=\"http://blog.thoughtram.io/angularjs/2014/11/06/exploring-angular-1.3-angular-hint.html\">Angular-hint</a> or <a href=\"http://blog.thoughtram.io/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html\">One-time Bindings</a> are not just minor improvements, but rather real extensions to the framework. However, there have not only been significant new features added to the release, but also a ton of bug fixes and nice little additions that we might have overlooked. One of them is the ES6 streamlined promise API and today we gonna take a look what it brings to the table.</p>\n<h2>Asynchronous worlds with Promises</h2>\n<p>In order to understand what the new streamlined addition to the existing promise API means, we first have to make sure we’re all on the same page and know what promises are and how they’ve been implemented in Angular before. We don’t want to go in too much detail here though, since there are a ton of resources in the interwebs, but let’s take a very quick look at promises and move on then.</p>\n<p>In just one sentence, a promise is an object that is used for deferred and asynchronous computations. So what does that mean? Well, in JavaScript we can have asynchronous code execution with, for example, callbacks. And with these things we’re able to execute some code once another execution that ran before is done without blocking the actual code execution context. We call this <em>asynchronous</em>.</p>\n<p>Here’s an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">onceDone(function () {\n  // do something once `onceDone()` calls you\n});</code></pre></div>\n<p>Here we have a function <code class=\"language-text\">onceDone()</code> that expects a function that is executed, once the <code class=\"language-text\">onceDone()</code> function is done with its work and it doesn’t block the rest of the code that might be there.</p>\n<p>Okay, that’s clear. But where and how come promises into play? There’s a scenario that JavaScript developers love to call ”<em>callback hell</em>”. Callback hell is something that we have, when we nest a lot of functions in JavaScript that are asynchronous and have callbacks to be executed. Just take a look at the following code snippet.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">onceDone(function (files) {\n  files.forEach(function (filename, fileIndex) {\n    filename.size(function (err, values) {\n      values.width.forEach(function (value) {\n        // ... and so on\n      });\n    });\n  });\n});</code></pre></div>\n<p>You get the idea right? While it is very common to have function calls that get a function callback, it can lead to very hard to get right code when we have to nest a lot of these. I recommend to head over to <a href=\"http://callbackhell.com\">callbackhell.com</a> to get a better picture, if things are still unclear.</p>\n<p>We can get around this issue by defining named functions first, and pass just these as callbacks instead of using anonymous functions all the time, but it’s still not a very handy way to handle asynchronous JavaScript. And this is where promises come in.</p>\n<p>Promises are a software abstraction or proxies, that make working with asynchronous operations much more pleasant. Coming back to our <code class=\"language-text\">onceDone()</code> function example, here’s what the code would look like if <code class=\"language-text\">onceDone()</code> used promises.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var promise = onceDone();\n\npromise.then(function () {\n  // do something once `onceDone` calls you\n});</code></pre></div>\n<p>Looks very similar right? But there’s a huge difference. As you can see, <code class=\"language-text\">onceDone()</code> returns something that is a promise which we can treat as first-class objects. This promise holds the actual state of the asynchronous code that has been called, which can be <code class=\"language-text\">fulfilled</code>, <code class=\"language-text\">rejected</code> or <code class=\"language-text\">pending</code>. We can pass promises around and even aggregating them. That’s a whole different way of handling our asynchronous code.</p>\n<p>What we also see, is that the promise has a method <code class=\"language-text\">.then()</code>. This method expects two parameters which are functions of which one gets called when the asynchronous execution was fulfilled and the other one when it was rejected.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var promise = functionThatReturnsAPromise();\n\npromise.then(fulfilledHandler, rejectedHandler);</code></pre></div>\n<p>As I mentioned, we can aggregate them. <code class=\"language-text\">.then()</code> also returns a promise that resolves with the return value of the executed handler (<code class=\"language-text\">fulfilled</code> or <code class=\"language-text\">rejected</code>). That enables us to chain promises like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var promise = functionThatReturnsAPromise();\n\npromise\n  .then(fulfilledHandler, rejectedHandler)\n  .then(doSomethingElse)\n  .then(doEvenMore)\n  .then(doThis);</code></pre></div>\n<p>Compare this with our callback hell code snippet and you know why promises are so powerful. In fact, there’s <strong>a lot</strong> more about promises to tell, but that’s out of the scope of this article. If you want to read more about promises in general, I recommend reading <a href=\"https://blog.domenic.me/youre-missing-the-point-of-promises/\">Domenic’s article</a> and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN docs</a> on promises. But let’s get back to promises in Angular.</p>\n<h2>Promises in Angular and <code class=\"language-text\">$q</code></h2>\n<p>Angular comes with a promise implementation by default. It has a <a href=\"https://docs.angularjs.org/api/ng/service/$q\">$q</a> service that we can of course inject and use though-out our application. Angular’s implementation is highly inspired by <a href=\"https://github.com/kriskowal/q\">Kris Kowal’s Q library</a> which is an implementation of the <a href=\"https://promisesaplus.com/\">Promises/A spec</a>.</p>\n<p>It comes with a <code class=\"language-text\">Deferred API</code> which lets you get instances of deferred objects that hold a promise object. We can use the API of a deferred to either resolve or reject a promise depending on what our code should do. Here’s a quick example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// `$q` is injected before\n\nvar deferred = $q.defer();\n\nanAsyncFunction(function (success) {\n  deferred.resolve(success);\n}, function (error) {\n  deferred.reject(error);\n});\n\nvar promise = deferred.promise;\n\n// and later\n\npromise.then(function () {\n  // do something when `anAsyncFunction` fulfilled\n});</code></pre></div>\n<p>We have a function <code class=\"language-text\">anAsyncFunction()</code> which is asynchronous and we use the deferred API to get a promise out of it. One thing to notice here is that our function doesn’t know anything about promises but we use the deferred API to get a promise back. The deferred API comes with a few more features that I don’t want to detail here, but you can read about them in the <a href=\"https://docs.angularjs.org/api/ng/service/$q#the-deferred-api\">official docs</a>.</p>\n<p>Have you ever used Angular’s <code class=\"language-text\">$http</code> service? Sure you did. And as we know, XMLHttpRequests are asynchronous too. Guess what <code class=\"language-text\">$http</code> service uses to expose its <code class=\"language-text\">.success()</code> and <code class=\"language-text\">.error()</code> APIs? Right. Promises. When making XHR calls with <code class=\"language-text\">$http</code> we’re also using <code class=\"language-text\">$q</code> implicitly. It just adds some sugar APIs to the promise it returns:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$http.get(&#39;some/restful/endpoint&#39;)\n  .success(function (data) {\n    // do something with `data`\n  })\n  .error(function (reason) {\n    // oups, something went wrong\n  });</code></pre></div>\n<p>In fact, we can use the promise native APIs to achieve the same:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$http.get(&#39;some/restful/endpoint&#39;)\n  .then(function (data) {\n    // do something with `data`\n  }, function (reason) {\n    // oups, something went wrong\n  });</code></pre></div>\n<p>Okay, so we now got a picture of promises in Angular. There’s also a nice talk by the awesome <a href=\"https://www.youtube.com/watch?v=33kl0iQByME\">Dave</a> on promises at <a href=\"http://ngeurope.org\">ngEurope</a>, I recommend checking that one out too. But what is it with the ES6 style promises that we’ve mentioned in the blog title?</p>\n<h2>ES6 style Promises in Angular 1.3</h2>\n<p>Although it’s nice to have the deferred API in Angular to deal with promises, it turns out that the ECMAScript standard defines a slight different API. Taking a look at the <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\">MDN docs on Promises</a>, we see that <code class=\"language-text\">Promise</code> is a constructor in ES6 that takes an <code class=\"language-text\">executor</code> function that has access to a <code class=\"language-text\">resolve</code> and a <code class=\"language-text\">reject</code> function to resolve and reject promises respectively.</p>\n<p>Angular 1.3 streamlined its promise APIs <strong>partly</strong> with the ES6 standard. I say partly here, because not all methods are supported yet. However, what the team <em>has</em> streamlined is that <code class=\"language-text\">$q</code> can also be used as a constructor now.</p>\n<p>So instead of doing creating a deferred like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function myFunctionThatReturnsAPromise() {\n  var deferred = $q.defer();\n\n  anAsyncFunction(function (success) {\n    deferred.resolve(success);\n  }, function (error) {\n    deferred.reject(error);\n  });\n\n  return deferred.promise;\n}\n\nmyFunctionThatReturnsAPromise().then(yay, nay);</code></pre></div>\n<p>We can now use the promise constructor API and return it directly without creating a deferred object first:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function myFunctionThatReturnsAPromise() {\n  return $q(function (resolve, reject) {\n    anAsyncFunction(function (success) {\n      resolve(success);\n    }, function (error) {\n      reject(error);\n    });\n  });\n}</code></pre></div>\n<p>Even if this is just an optical difference at a first glance, it’s nice to know that we can safe the lines of code to create a deferred first. Also, the fact that the <code class=\"language-text\">$q</code> API is now closer to the actual spec makes the code more reusable in the future.</p>\n<p>Now we might wonder, if we have to change all of our code where we’ve used <code class=\"language-text\">$q.defer()</code> to work with promises. The answer is no. As mentioned at the beginning of the article, this is a nice small addition (rather than a new feature or replacement) in the 1.3 release that doesn’t break the code.</p>","frontmatter":{"author":"pascal_precht","title":"ES6 Style Promises in Angular 1.3","imageUrl":null,"date":"18 December 2014","summary":"Angular 1.3 starts streamlining its promise APIs with the ES2015 standard. This article details what these additions mean to us.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2014/12/18/exploring-angular-1.3-es6-style-promises.html","previous":{"fields":{"slug":"/angularjs/2014/11/19/exploring-angular-1.3-stateful-filters.html"},"frontmatter":{"date":"2014/11/19","title":"Stateful filters in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2014/12/22/exploring-angular-1.3-disabling-debug-info.html"},"frontmatter":{"date":"2014/12/22","title":"Disabling Debug Info in Angular 1.3","categories":["angularjs"]}}}}}
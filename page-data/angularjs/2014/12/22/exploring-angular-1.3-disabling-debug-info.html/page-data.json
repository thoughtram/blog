{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2014/12/22/exploring-angular-1.3-disabling-debug-info.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"3f1862c6-caf2-5b00-a4cb-c577fea4b063","excerpt":"Angular has some cool new features that improve our production code. And since these are a bit shadowed by all the other bigger features that come with 1.3, we…","html":"<p>Angular has some cool new features that improve our production code. And since these are a bit shadowed by all the other bigger features that come with 1.3, we’re going to take a look at one of them: <strong>Disabling Debug Info</strong>.</p>\n<p>Sure, disabling debug info doesn’t really sound super special and in fact, it really isn’t. However, it turns out that it can have a huge impact on our applications performance, so it’s definitely worth a mention in our blog series on exploring Angular 1.3.</p>\n<p>So, what is the debug info we’re talking about anyway?</p>\n<h2>Debug Info in Angular</h2>\n<p>When using certain directives, Angular attaches some additional debug information to the elements they are applied to. For example, when we use the interpolation directive to evaluate an expression in our template, Angular adds an additional <code class=\"language-text\">ng-binding</code> class to the directive’s, or directive’s parent element.</p>\n<p>For example, if we have a scope property like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.controller(&#39;AppController&#39;, [&#39;$scope&#39;, function ($scope) {\n  $scope.name = &#39;Pascal&#39;;\n}]);</code></pre></div>\n<p>And an expression in our HTML code like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>What we get, once compiled, is this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p class=&quot;ng-binding&quot;&gt;Hello Pascal!&lt;/p&gt;</code></pre></div>\n<p>The same happens when using <code class=\"language-text\">ng-bind</code> or <code class=\"language-text\">ng-bind-html</code> directives. The former is an equivalent to the interpolation directive, in form of an attribute to prevent flash of uncompiled content flickering. The latter lets us evaluate expressions that have HTML code as value while the HTML itself is interpreted by the browser (use of <code class=\"language-text\">$sce.trustAsHtml()</code> required here).</p>\n<p>To make things a bit more clear, here’s our example as <code class=\"language-text\">ng-bind</code> version:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;!&lt;/p&gt;</code></pre></div>\n<p>Which would end up in a DOM that looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello &lt;span class=&quot;ng-binding&quot; ng-bind=&quot;name&quot;&gt;Pascal&lt;/span&gt;!&lt;/p&gt;</code></pre></div>\n<p>Angular has some more cases where additional debug information is attached to an element. When Angular’s compiler creates a new scope, it adds either <code class=\"language-text\">ng-scope</code> or <code class=\"language-text\">ng-isolated-scope</code> classes to the element, depending on what kind of scope is created. So for example, having a directive like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.directive(&#39;myComponent&#39;, function () {\n  return {\n    scope: {},\n    template: &#39;This is a component with isolated scope.&#39;\n  };\n});</code></pre></div>\n<p>Which is used like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;my-component&gt;&lt;/my-component&gt;</code></pre></div>\n<p>Creates this compiled DOM:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;my-component class=&quot;ng-isolated-scope&quot;&gt;\n  This is a component with isolated scope.\n&lt;/my-component&gt;</code></pre></div>\n<p>As we can see, the compiler adds an <code class=\"language-text\">ng-isolated-scope</code> class to that element, because it has an isolated scope. But that’s not all. What also happens is, that the actual scope is added to the DOM element as well. Wait… the scope object itself? Hey that means we can access it imperatively in JavaScript, right? Yes!</p>\n<p>Depending on what type of scope is created, the corresponding element gets either a <code class=\"language-text\">.scope()</code> or <code class=\"language-text\">.isolateScope()</code> method, that we can call to access the scope object for debugging purposes. Just notice that with <code class=\"language-text\">element</code> we refer to <code class=\"language-text\">angular.element()</code>.</p>\n<p>Running the following code in a browser console would display the components scope object:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">angular\n  .element(document.querySelector(&#39;my-component&#39;))\n  .isolateScope();</code></pre></div>\n<p>Now we may wonder why these classes and element properties are added by the compiler. It turns out that tools like <a href=\"http://angular.github.io/protractor/#/\">Protractor</a> and the <a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en\">Angular Batarang</a> need all this information to actually run. Batarang for example displays scope data in the developer tools.</p>\n<h2>Disabling debug info for production</h2>\n<p>Having Angular providing all this information in our application is super useful when it comes to debugging. Tools like Protractor and Batarang can rely on that data and make debugging even easier. However, additional properties and classes that are added to the DOM also come with a performance cost depending on how much is stored on the scope and DOM operations are expensive anyway.</p>\n<p>What we need is a way to actually turn off this behaviour when an application is deployed to production, because we usually don’t need this information there. Luckily Angular has exactly that switch since version 1.3. In order to turn off this default behaviour, all we have to do is to call the <code class=\"language-text\">.debugInfoEnabled()</code> method on the <code class=\"language-text\">$compileProvider</code> during our application’s configuration phase (since this is the only place where we have access to providers).</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.config([&#39;$compileProvider&#39;, function ($compileProvider) {\n  // disable debug info\n  $compileProvider.debugInfoEnabled(false);\n}]);</code></pre></div>\n<p>Yay, just one line of code and our production application runs faster! But what if we <strong>do</strong> want to have this debug information in our application because something’s wrong in our production environment and we need to debug?</p>\n<p>Angular got us covered. The global <code class=\"language-text\">angular</code> object comes with a new <code class=\"language-text\">.reloadWithDebugInfo()</code> method, which does exactly what it says. It reloads the browser with debug information to make your life easier again. And since the <code class=\"language-text\">angular</code> object is global, we can just call it directly from the browsers console. Neat ha?</p>\n<p>Note! When you disable debugInfo, you will no longer be able to do <code class=\"language-text\">$element.scope()</code> or <code class=\"language-text\">$element.isolateScope()</code>. If your code is relying on these methods, you will need to refactor.</p>","frontmatter":{"author":"pascal_precht","title":"Disabling Debug Info in Angular 1.3","imageUrl":null,"date":"22 December 2014","summary":"This article details how to give your app a performance boost in production environments with just a single line of code.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2014/12/22/exploring-angular-1.3-disabling-debug-info.html","previous":{"fields":{"slug":"/angularjs/2014/12/18/exploring-angular-1.3-es6-style-promises.html"},"frontmatter":{"date":"2014/12/18","title":"ES6 Style Promises in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/angularjs/2015/01/02/exploring-angular-1.3-bindToController.html"},"frontmatter":{"date":"2015/01/02","title":"Binding to Directive Controllers in Angular 1.3","categories":["angularjs"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2014/11/19/exploring-angular-1.3-stateful-filters.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"1ae0c516-c99d-5362-a851-cdd12cd3b756","excerpt":"Angular 1.3 comes with a lot of cool features and improvements. We already covered a couple of them. You can for example read about one-time bindings…","html":"<p>Angular 1.3 comes with a lot of cool features and improvements. We already covered a couple of them. You can for example read about <a href=\"http://blog.thoughtram.io/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html\">one-time bindings</a>, <a href=\"http://blog.thoughtram.io/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html\">ngModelOptions</a> or the newly introduced <a href=\"http://blog.thoughtram.io/angularjs/2014/11/06/exploring-angular-1.3-angular-hint.html\">Angular-hint</a> module that helps you out writing better Angular code.</p>\n<p>However, it turns out that, even if the 1.3 release looks like a feature release, it comes with a change that might break your existing code. It handles all filters stateless by default and in this article we’re going to take a look at what this means and how we can deal with that.</p>\n<h2>The filter behaviour you know</h2>\n<p>I think I don’t have to go into much detail when it comes to how to use filters in general. We apply them with a <code class=\"language-text\">|</code> symbol in our interpolation expressions and are able to pass additional parameters by chaining them with a <code class=\"language-text\">:</code> symbol.</p>\n<p>For instance, in the following example, we use the <code class=\"language-text\">json</code> filter to convert a JavaScript object into a JSON string:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{{ jsonExpression | json }}</code></pre></div>\n<p>Expecting <code class=\"language-text\">jsonExpression</code> to look something like: <code class=\"language-text\">{&#39;name&#39;:&#39;value&#39;}</code>, the filter would return a string that looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  &quot;name&quot;: &quot;value&quot;\n}</code></pre></div>\n<p>If we use a filter that can be configured with additional parameters, we can pass them to the filter by chaining them with a <code class=\"language-text\">:</code> symbol right in the expression. The following example uses the <code class=\"language-text\">currency</code> filter to format the given expression accordingly and uses an optional <code class=\"language-text\">symbol</code> parameter to change the default currency symbol for this particular use case.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{{ amount | currency:&#39;€&#39; }}</code></pre></div>\n<p>Okay, so this is pretty straight forward right? A filter takes an expression and uses it as input to manipulate the expressions value and returns (ideally) a string, so it can be used in our HTML right away.</p>\n<p>We can go even further and build a custom filter that depends on another service to manipulate the given input. Let’s assume we have a filter like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">angular.module(&#39;myApp&#39;, [])\n\n.filter(&#39;customFilter&#39;, [&#39;someService&#39;, function (someService) {\n  return function customFilter(input) {\n    // manipulate input with someService\n    input += someService.getData();\n    return input;\n  };\n}]);</code></pre></div>\n<p>In this example we have a filter that depends on <code class=\"language-text\">someService</code> and this particular service apparently comes with a method <code class=\"language-text\">getData()</code>, which is used to change the value of <code class=\"language-text\">input</code> that gets returned.</p>\n<p>Again, this is pretty straight forward. Filters in Angular follow the same rules as other component types like services, factories etc, when it comes to dependency injection. So basically it’s totally fine and valid to have dependencies in filter components. However, <strong>filters that have dependencies are usually stateful</strong>. And this is where the code might break.</p>\n<p>But what does that mean? And why is it a problem at all? Well, let’s take a look at what changed in Angular 1.3, so we get a better idea of what causes problems.</p>\n<h2>Filters in 1.3</h2>\n<p>In order to make Angular faster, a lot of changes landed in the 1.3 release that come with performance improvements. One of them is how filters behave by default. We talked about what filters do and how we can use them, but we didn’t talk about the fact, that they always came with a relatively big drawback. Each filter creates a new watcher. Having to many watchers registered can slow down our app, since the more watchers are registered, the more work has to be done during the <code class=\"language-text\">$digest</code> cycle. That’s why we usually should avoid using too many filters.</p>\n<p>However, there’s a reason why <a href=\"http://twitter.com/IgorMinar\">Igor Minar</a> said that:</p>\n<blockquote>\n<p>“Angular 1.3 is the best Angular yet!”</p>\n</blockquote>\n<p>In version 1.3, filters are much smarter. By default, they cache the evaluated value so they don’t have to be re-evaluated all the time. Getting back to our simple <code class=\"language-text\">{% raw %}{{ jsonExpression | json}}{% endraw %}</code> example, the expression only gets re-evaluated when <code class=\"language-text\">jsonExpression</code> changes, which makes our code execution much faster.</p>\n<p>To make it work like this, Angular assumes that, as long as the passed expression doesn’t change, the result of the expression doesn’t change either. It’s <strong>stateless</strong>. And this is where our code might break. Think about what that means in cases where your filter depends on other services, like our <code class=\"language-text\">customFilter</code>.</p>\n<p>But to get a better picture, let’s take a look at the <code class=\"language-text\">translate</code> filter that comes with the <a href=\"http://angular-translate.github.io\">angular-translate</a> module. It consumes translation ids to look them up in a registered translation table, using the <code class=\"language-text\">$translate</code> service and returns the dedicated translation. <strong>It is stateful</strong>.</p>\n<p>Here’s what it looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{{ &#39;TRANSLATIONID&#39; | translate }}</code></pre></div>\n<p>As we already discussed, Angular caches the value of this expression and won’t re-evaluate it unless <code class=\"language-text\">&#39;TRANSLATIONID&#39;</code> changes. This is actually a problem, because <code class=\"language-text\">&#39;TRANSLATIONID&#39;</code> never changes. When the user changes the language, the given translation id again, is looked up by the filter in a translation table, but the expression stays the exact same.</p>\n<p>So how do we tell Angular, that expressions that are stateful  <em>have</em> to be re-evaluated? It’s easy. All we have to do is to add a <code class=\"language-text\">$stateful</code> property to our filter that flags it as stateful. Here we see our <code class=\"language-text\">customFilter</code> being flagged accordingly:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">angular.module(&#39;myApp&#39;, [])\n\n.filter(&#39;customFilter&#39;, [&#39;someService&#39;, function (someService) {\n  function customFilter(input) {\n    // manipulate input with someService\n    input += someService.getData();\n    return input;\n  }\n\n  customFilter.$stateful = true;\n\n  return customFilter;\n}]);</code></pre></div>\n<p>That’s it. Setting the <code class=\"language-text\">$stateful</code> property to <code class=\"language-text\">true</code> does the trick (angular-translate’s filter comes with that flag already). Keep in mind that it’s in general recommended to avoid building stateful filters, because the execution of those can’t be optimized by Angular. Better build stateless filters that get all needed information as parameters.</p>\n<p>To sum it up, make sure to flag your stateful filters as stateful in order to make them work with Angular 1.3. Hopefully this article made clear why these changes are a requirement.</p>","frontmatter":{"author":"pascal_precht","title":"Stateful filters in Angular 1.3","imageUrl":null,"date":"19 November 2014","summary":"Angular 1.3 makes all filters stateless by default. In this article we're going to take a look what that means.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2014/11/19/exploring-angular-1.3-stateful-filters.html","previous":{"fields":{"slug":"/git/2014/11/18/the-anatomy-of-a-git-commit.html"},"frontmatter":{"date":"2014/11/18","title":"The anatomy of a Git commit","categories":["git"]}},"next":{"fields":{"slug":"/angularjs/2014/12/18/exploring-angular-1.3-es6-style-promises.html"},"frontmatter":{"date":"2014/12/18","title":"ES6 Style Promises in Angular 1.3","categories":["angularjs"]}}}}}
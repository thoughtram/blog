{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"b4313b82-a7f4-5a00-a3d8-baab8e7c2868","excerpt":"Hi again. This is the second article of “Exploring Angular 1.3”. If you haven’t read the first one you might want to check out that too. In this article, we…","html":"<p>Hi again. This is the second article of “Exploring Angular 1.3”. If you haven’t read the <a href=\"/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html\">first one</a> you might want to check out that too. In this article, we cover another feature that turns out to be very useful in our daily development of Angular applications. Introducing the <code class=\"language-text\">ngModelOptions</code> directive.\nWe’ve written a few other articles on 1.3 already. Here’s a list:</p>\n<ul>\n<li><a href=\"http://blog.thoughtram.io/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html\">Exploring Angular 1.3 - One-time bindings</a></li>\n<li><a href=\"http://blog.thoughtram.io/angularjs/2014/11/06/exploring-angular-1.3-angular-hint.html\">Exploring Angular 1.3 - Angular-hint</a></li>\n</ul>\n<p><code class=\"language-text\">ngModelOptions</code> allows us to control how <code class=\"language-text\">ngModel</code> updates are done. This includes things like updating the model only after certain events are triggered or a debouncing delay, so that the view value is reflected back to the model only after a timer expires. To get an idea of what that actually means, let’s start with the probably simplest use case that sets up a two-way binding using an <code class=\"language-text\">input</code> element that has a <code class=\"language-text\">ngModel</code> directive applied:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;\n&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>Now, when typing something into the <code class=\"language-text\">input</code> element, the model gets updated accordingly and then reflected back to the view, which displays the value in our <code class=\"language-text\">p</code> element.</p>\n<p><a href=\"http://weknowgifs.com/wp-content/uploads/2013/03/its-magic-shia-labeouf-gif.gif\">Magic</a>. If you’re not familiar with what’s going on here, I recommend heading over to the official docs and reading the chapter about the <a href=\"https://docs.angularjs.org/guide/concepts\">concepts of Angular</a>.</p>\n<p>The reason why the view is updated immediately, is that every time the <code class=\"language-text\">input</code> element fires an <code class=\"language-text\">input</code> event, Angulars <code class=\"language-text\">$digest</code> loop is executed until the model stabilizes. And that’s nice because we don’t have set up any event listeners and update the DOM manually to reflect model values in the view; Angular takes care of that.</p>\n<p>However, that also means that, because of the <code class=\"language-text\">$digest</code> that happens to be triggered on every single keystroke,  Angular has to process all registered watchers on the scope whenever you type something into the <code class=\"language-text\">input</code> element. Depending on how many watchers are registered and of course how efficient the watcher callbacks are, this can be very expensive. So wouldn’t it be great if we could somehow manage to trigger a <code class=\"language-text\">$digest</code> only after the user stopped typing for, let’s say, 300 milliseconds? Or only when the user removes the focus of the <code class=\"language-text\">input</code> element?</p>\n<p>Yes, and we can do so thanks to Angular 1.3 and the <code class=\"language-text\">ngModelOptions</code> directive.</p>\n<h2>Updating <code class=\"language-text\">ngModel</code> with <code class=\"language-text\">updateOn</code></h2>\n<p><code class=\"language-text\">ngModelOptions</code> comes with a couple of options to control how <code class=\"language-text\">ngModel</code> updates are done. With the <code class=\"language-text\">updateOn</code> parameter, we can define which events our <code class=\"language-text\">input</code> should be bound to. For example, if we want our model to be updated only after the user removed the focus of our <code class=\"language-text\">input</code> element, we can simply do so by applying the <code class=\"language-text\">ngModelOptions</code> with the following configuration:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input\n  type=&quot;text&quot;\n  ng-model=&quot;name&quot;\n  ng-model-options=&quot;{ updateOn: &#39;blur&#39; }&quot;&gt;\n&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>This tells Angular that instead of updating the model immediately after each keystroke, it should only update when the <code class=\"language-text\">input</code> fires an <code class=\"language-text\">onBlur</code> event.</p>\n<p>If we do want to update the model with the default events that belong to that control and add other events on top of that, we can use a special event called <code class=\"language-text\">default</code>. Adding more then just one event can be done with a space delimited list. The following code updates the model whenever a user types into the input, or removes the focus of it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input\n  type=&quot;text&quot;\n  ng-model=&quot;name&quot;\n  ng-model-options=&quot;{ updateOn: &#39;default blur&#39; }&quot;&gt;\n&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>Alright, now that we know how that works, let’s take a look at how we can update the model after a timer expires.</p>\n<h2>Delaying the model update with <code class=\"language-text\">debounce</code></h2>\n<p>We can delay the model update with <code class=\"language-text\">ngModelOptions</code> in order to reduce the amount of <code class=\"language-text\">$digest</code> cycles that are going to be triggered when a user interacts with our model. But not only that this ensures fewer <code class=\"language-text\">$digest</code> cycles, it’s also a powerful feature that can be used to implement a nice user experience when dealing with asynchronous code execution.</p>\n<p>Just imagine an <code class=\"language-text\">input[type=&quot;search&quot;]</code> element, where every time a user types into the field, the model gets updated and an asynchronous request is made to a server to get a response with search results depending on the given query. This works. However, we probably don’t want to update the model on every keystroke but rather once the user has finished typing a meaningful search term. We can do exactly that with <code class=\"language-text\">ngModelOptions</code>’ <code class=\"language-text\">debounce</code> parameter.</p>\n<p><code class=\"language-text\">debounce</code> defines an integer value which represents a model update delay in milliseconds. Which means, if we take the example mentioned above, that we want to update our model 300 milliseconds after the user stopped typing, we can do so by defining a debounce value of <code class=\"language-text\">300</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input\n  type=&quot;search&quot;\n  ng-model=&quot;searchQuery&quot;\n  ng-model-options=&quot;{ debounce: 300 }&quot;&gt;\n&lt;p&gt;Search results for: {{searchQuery}}&lt;/p&gt;</code></pre></div>\n<p>Now, when typing into the <code class=\"language-text\">input</code> field, there’s a slight delay until the model updates.</p>\n<p>We can go even further and configure how the update delay should be done for certain events. Controlling the debounce delay for specific events can be done by defining an object literal instead of a primitive integer value, where keys represent the event name and values the debounce delay. A delay of <code class=\"language-text\">0</code> triggers an immediate model update.</p>\n<p>The following code generates a model update delay of 300 milliseconds when the user types into our <code class=\"language-text\">input</code>, but an immediate update when removing the focus:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;input\n  type=&quot;search&quot;\n  ng-model=&quot;searchQuery&quot;\n  ng-model-options=&quot;{ updateOn: &#39;default blur&#39;, debounce: { &#39;default&#39;: 300, &#39;blur&#39;: 0 } }&quot;&gt;\n&lt;p&gt;Search results for: {{searchQuery}}&lt;/p&gt;</code></pre></div>\n<p>Super powerful right? There are a few other options that are worth to checkout out. You can read about them in the <a href=\"https://docs.angularjs.org/api/ng/directive/ngModelOptions\">official docs</a>.</p>\n<h2>Synchronizing model and view with <code class=\"language-text\">$rollbackViewValue</code></h2>\n<p>Due to the fact that we are able to control with <code class=\"language-text\">ngModelOptions</code> how and when model updates are done, the model and the view can get out of sync. For example, when we configure our <code class=\"language-text\">input</code> element to update the model only when it loses its focus, the moment when the user types into the field, the <code class=\"language-text\">input</code> value differs from the actual value in the model.</p>\n<p>There might be situations, where you want to roll the view value back to what it was, before the change has been made. For such cases, Angular introduces a so called <code class=\"language-text\">$rollbackViewValue</code> method that can be invoked to synchronize the model and view. Basically what this method does is, it takes the value that is currently in the model and reflects it back to the view. In addition, it cancels all debounced changes.</p>\n<p>To demonstrate this use case, we can setup a <code class=\"language-text\">form</code> that has an <code class=\"language-text\">input</code> element that updates the model when the user removes the focus. As long as the user didn’t remove the focus of the <code class=\"language-text\">input</code> element, he can hit the <code class=\"language-text\">Esc</code> key to discard his changes and get the value of the model back.</p>\n<p>So it turns out that <code class=\"language-text\">ngModelOptions</code> is a super powerful directive that helps us making our apps more intuitive. Go and check out the <a href=\"https://code.angularjs.org/1.3.0/docs/api/ng/directive/ngModelOptions\">docs</a> about the <code class=\"language-text\">allowInvalid</code> and <code class=\"language-text\">getterSetter</code> options, to see what else is possible!</p>","frontmatter":{"author":"pascal_precht","title":"ng-model-options in Angular 1.3","imageUrl":null,"date":"19 October 2014","summary":"In this article we explore the brand new ngModelOptions directive that allows us to control how ngModel updates are done in our Angular applications.","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html","previous":{"fields":{"slug":"/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html"},"frontmatter":{"date":"2014/10/14","title":"One-time bindings in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/announcements/2014/11/02/git-ninja-class-in-amsterdam.html"},"frontmatter":{"date":"2014/11/02","title":"Git Ninja Class in Amsterdam","categories":["announcements"]}}}}}
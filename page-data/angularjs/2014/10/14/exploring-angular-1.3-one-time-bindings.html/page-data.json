{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"a7b25d7b-494d-5354-89ef-a4dbf2d52c95","excerpt":"The time has come. Angular 1.3 is finally out and it comes with tons of new features, bug fixes, improvements but also breaking changes. And because of all this…","html":"<p>The time has come. <a href=\"http://angularjs.blogspot.de/2014/10/angularjs-130-superluminal-nudge.html\">Angular 1.3</a> is finally out and it comes with tons of new features, bug fixes, improvements but also breaking changes. And because of all this new stuff happening there, we thought it would make sense to help making the adaption of this release easier for all of us, by exploring its main features and improvements and make a blog series out of it. This is the first post of “Exploring Angular 1.3” and it covers one of the most important features ever: <strong>one-time binding</strong>.</p>\n<p>We’ve written a few other articles on 1.3 already. Here’s a list:</p>\n<ul>\n<li><a href=\"http://blog.thoughtram.io/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html\">Exploring Angular 1.3 - ng-model-options</a></li>\n<li><a href=\"http://blog.thoughtram.io/angularjs/2014/11/06/exploring-angular-1.3-angular-hint.html\">Exploring Angular 1.3 - Angular-hint</a></li>\n</ul>\n<p>Wait! Isn’t this Angular thing about databinding that automatically keeps the UI in sync? Well, yes it is and that’s great. However, Angulars implementation of databinding requires the framework to keep an eye on all values that are bound. This can lead to performance issues and one-time bindings are here to help. But before we explore one-time bindings, let’s understand Angulars concepts of databinding and watchers first.</p>\n<h2>Understanding data-binding and watchers</h2>\n<p>In order to make databinding possible, Angular uses <a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch\">$watch</a> APIs to observe model mutations on the scope. What the scope actually is and where it comes from, depends on your application code. If you don’t create a <em>child scope</em> by, for example, using the <code class=\"language-text\">ngController</code> directive to create an association between your DOM and your actual controller code, you’re probably dealing with the <a href=\"https://docs.angularjs.org/api/ng/service/$rootScope\">$rootScope</a>, which is (as the name says) the scope that acts as root scope for your application and created by Angular itself through the <code class=\"language-text\">ngApp</code> directive, unless you bootstrap your app manually.</p>\n<p>However, at some point you always deal with a scope and that one is used to observe changes on it with the use of so called <em>watchers</em>. Watchers are registered through <a href=\"https://docs.angularjs.org/guide/directive\">directives</a> that are used in the DOM. So let’s say we use the interpolation directive to reflect scope model values in the DOM:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>This interpolation directive registers a watch for a property <code class=\"language-text\">name</code> on the corresponding scope (which in our case is <code class=\"language-text\">$rootScope</code>) in order to interpolate against it to display the value in the DOM.</p>\n<p>Defining a property with exactly that identifier on our scope and assigning a value to it, makes it magically displaying it in the DOM without further actions:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">angular.module(&#39;myApp&#39;, [])\n.run(function ($rootScope) {\n  $rootScope.name = &quot;Pascal&quot;;\n});</code></pre></div>\n<p>Great! We just bound a model value to the view with an interpolation directive. If now something changes the value, the view gets updated automatically. Let’s add a button that updates the value of <code class=\"language-text\">name</code> once it’s clicked:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;button ng-click=&quot;name = &#39;Christoph&#39;&quot;&gt;Click me!&lt;/button&gt;</code></pre></div>\n<p>Clicking the button assigns the string <code class=\"language-text\">Christoph</code> to <code class=\"language-text\">name</code> which triggers a <a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest\">$digest</a> cycle that automatically updates the DOM accordingly. In this particular case we’re just updating the value one-way (top → down). However, when for example dealing with an <code class=\"language-text\">input</code> element that has an <a href=\"https://docs.angularjs.org/api/ng/directive/ngModel\">ngModel</a> directive applied, and a user changes its <code class=\"language-text\">value</code> property by typing something into it, the change is reflected back to the actual model.</p>\n<p>This happens because when a <code class=\"language-text\">$digest</code> cycle is triggered, Angular processes all registered watchers on the current scope and its children and checks for model mutations and calls dedicated watch listeners until the model is stabilized and no more listeners are fired. Once the <code class=\"language-text\">$digest</code> loop finishes the execution, the browser re-renders the DOM and reflects the changes.</p>\n<h2>The problem with too many watchers</h2>\n<p>Now that we have a picture of how the databinding mechanism in Angular actually works, we might wonder why there is a feature for one-time binding.</p>\n<p>Due to Angulars nature of using watchers for databinding, we might get some problems in terms of performance when having too many of them. As we learned, <em>watch expressions</em> are registered on the scope together with their callback listeners so Angular can process them during <code class=\"language-text\">$digest</code> cycles in order to update the view accordingly. That simply means, the more watchers are registered, the more Angular has to process.</p>\n<p>Now imagine you have a lot of dynamic values in your view that have to be evaluated by Angular. Internationalization for example, is a very common use case where developers use Angulars databinding to localize their apps, even if the language isn’t changeable during runtime, but set on initial page load. In that case every single string that is localized in the view and written to the scope, sets up a watch in order to get updated once something triggers the next <code class=\"language-text\">$digest</code>. This is a lot of overhead especially when your language actually doesn’t change at runtime.</p>\n<h2>One-time bindings to the rescue!</h2>\n<p>This is where one-time bindings come in. So what are one-time bindings? Let’s just read what the <a href=\"https://docs.angularjs.org/guide/expression#one-time-binding\">official docs</a> say:</p>\n<blockquote>\n<p>One-time expressions will stop recalculating once they are stable, which happens after the first digest…</p>\n</blockquote>\n<p>And this is exactly what the Angular world needs to tackle the problems mentioned above. So what does it look like when we want to use one-time binding? Angular 1.3 comes with a new syntax for interpolation directives and expressions in order to tell Angular that this particular interpolated value should be bound one-time.</p>\n<p>Using this new syntax is as easy as starting an expression with <code class=\"language-text\">::</code>. So if we apply the one-time expression to our example above, we change this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello {{name}}!&lt;/p&gt;</code></pre></div>\n<p>To this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;p&gt;Hello {{::name}}!&lt;/p&gt;</code></pre></div>\n<p>This works for all kind of typical Angular expressions you’re used to use throughout your app. Which means you can use them in <code class=\"language-text\">ng-repeat</code> expressions or even for directives that expose attributes that set up a two-way binding from the inside out. From the outside you’re able to just feed them with a one-time expression:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;custom-directive two-way-attribute=&quot;::oneWayExpression&quot;&gt;&lt;/custom-directive&gt;</code></pre></div>\n<p>Okay, let’s see it in action. We already updated the <code class=\"language-text\">name</code> to <code class=\"language-text\">::name</code> to ensure the one-time binding. The rest of the code just stays as it is to demonstrate that our one-time binding works. Remember the button we added to update the <code class=\"language-text\">name</code> to <code class=\"language-text\">Christoph</code>? Well, try it again.</p>\n<p>Perfect. <code class=\"language-text\">name</code> won’t ever change again. <code class=\"language-text\">Pascal</code> is a much better name anyway, right?</p>","frontmatter":{"author":"pascal_precht","title":"One-time bindings in Angular 1.3","imageUrl":null,"date":"14 October 2014","summary":"This article will be presenting Angular 1.3's new one-time binding feature for better performance and memory pressure. Read on for more info!","categories":["angularjs"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/2014/10/14/exploring-angular-1.3-one-time-bindings.html","previous":{"fields":{"slug":"/announcements/tools/2014/09/18/announcing-clog-a-conventional-changelog-generator-for-the-rest-of-us.html"},"frontmatter":{"date":"2014/09/18","title":"clog - A conventional changelog generator for the rest of us","categories":["announcements","tools"]}},"next":{"fields":{"slug":"/angularjs/2014/10/19/exploring-angular-1.3-ng-model-options.html"},"frontmatter":{"date":"2014/10/19","title":"ng-model-options in Angular 1.3","categories":["angularjs"]}}}}}
{"componentChunkName":"component---src-templates-blog-post-js","path":"/angularjs/es6/2015/01/23/exploring-angular-1.3-using-es6.html","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"d82f9dd9-edd2-5232-b07c-ca5e56848c7f","excerpt":"One of the most exciting upcoming changes for Angular 2.0 is that it’s entirely written in ES2015 - the next version of JavaScript. There’s no need to wait…","html":"<p>One of the most exciting upcoming changes for Angular 2.0 is that it’s entirely written in ES2015 - the next version of JavaScript. There’s no need to wait until Angular 2.0 though. You can start writing your Angular apps with ES2015 today - even with Angular 1.x.</p>\n<p>In this post we are going to look at two very exciting ES2015 features and how they can play a role in the context of an Angular application: <strong>Modules</strong> and <strong>Inheritance</strong>.</p>\n<h2>Modules</h2>\n<p>Modules are one of the most exciting features of ES2015. They enable us to decouple our code easier than ever before. The concept isn’t all that new as most programming languages have some kind of module system. Using JavaScript, your best bet so far was to use one of the community projects such as <a href=\"http://requirejs.org/\">requirejs</a>. With ES2015 a proper module standard is coming right into your browser, natively. With modules code can be structured to explicitly import all dependencies that are used in a file. Before a module can imported it first needs to be exported as a module.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function MainController () {\n  \n}\n\nexport { MainController }</code></pre></div>\n<p>Once a module has been exported it can easily be imported from another file.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { MainController } from &#39;./path/to/MainController&#39;;</code></pre></div>\n<h2>Inheritance</h2>\n<p>First things first: Inheritance is one of the most over abused software patterns of all times. If you aren’t family with the difference of <a href=\"http://en.wikipedia.org/wiki/Is-a\">Is-A and Has-A</a> relationships, please take a moment and read it up. Similary, if you aren’t aware that you should favor <a href=\"http://en.wikipedia.org/wiki/Composition_over_inheritance\">composition over inheritance</a>, please take a moment to read the linked article.</p>\n<p>Most programmers that are coming from traditional languages such as Java or C# have been using inheritance for many years. In fact, it has been possible to use inheritance with JavaScript for years, too. Using it without further abstractions has been very clunky though. There is a huge number of libraries and frameworks that invent some kind of it’s own DSL to make inheritance more approachable with JavaScript.</p>\n<p>With ES2015 we don’t need to rely on such non standard abstractions anymore. ES2015 defines a few new keywords and syntax additions that allow for easier inheritance. What’s important to know is that it’s really only sugar on top of the good old prototypal inheritance model that we’ve been using for years.</p>\n<p>To use inheritance we need to make use of the new <code class=\"language-text\">class</code> keyword.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Vehicle {\n\n    constructor (name) {\n        this._name = name;\n    }\n\n    get name () {\n        return this._name;\n    }\n}\nexport { Vehicle }</code></pre></div>\n<p>In the example above we construct a simple <code class=\"language-text\">Vehicle</code> class which isn’t different from a simple constructor function in ES5. Where the new class syntax really shines is when you want to inherit from another constructor function. Let’s write a <code class=\"language-text\">Car</code> class that inherits from <code class=\"language-text\">Vehicle</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Vehicle } from &#39;./Vehicle&#39;;\n\nclass Car extends Vehicle {\n\n    move () {\n        console.log(this.name + &#39; is spinning wheels...&#39;)\n    }\n}\nexport { Car }</code></pre></div>\n<p>Seen that? We import <code class=\"language-text\">Vehicle</code> as a module and extend it by using the new <code class=\"language-text\">extends</code> keyword. We could have done the same with ES5 but it’s much more boilerplate code. Let’s forget about the nice module seperation for a moment and put both <code class=\"language-text\">Vehicle</code> and <code class=\"language-text\">Car</code> into one file for the ES5 version.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//Vehicle\nfunction Vehicle (name) {\n    this._name = name;\n}\n\nObject.defineProperty(Vehicle.prototype, &#39;name&#39;, {\n    get: function () { return this._name; },\n    set: function (value) { this._name = value }\n});\n\n\n// Car\nfunction Car (name) {\n    Vehicle.call(this, name);\n}\n\nCar.prototype = Object.create(Vehicle.prototype);\nCar.prototype.constructor = Car;\n\nCar.prototype.move = function () {\n    console.log(this.name + &#39; is spinning wheels...&#39;);\n}</code></pre></div>\n<p>Oh wow, things really got a lot easier with ES2015, no?</p>\n<p>Now that we know what modules and inheritance mean in the context of ES2015, let’s take a look at how we can actually use it with Angular today.</p>\n<h2>Angular and ES modules</h2>\n<p>Let’s first look at ES2015 modules in the context of Angular 1.x. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class MainController {\n\n    constructor(searchService) {\n        this.searchService = searchService;\n    }\n\n    search () {\n        this.searchService\n            .fetch(this.searchTerm)\n            .then(response =&gt; {\n                this.items = response.data.items;\n            });\n    }\n}\nexport { MainController }</code></pre></div>\n<p>Notice something? There’s no Angular in our controller definition at all. It’s plain old JavaScript code that happens to be in control of something.</p>\n<p>The spirit of Angular has always been to stay out of the way of the developer as much as possibles. It embraces simple POJOs instead of special Angular object types. With ES2015 modules it’s even easier to excell on that idea. You can write your controller as a simple constructor function and have it exported as an ES2015 module.</p>\n<p>At some point though, we need to make Angular aware of the controller. Otherwise it just won’t play any role in our Angular application.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { MainController } from &#39;./MainController&#39;;\nimport { SearchService } from &#39;./SearchService&#39;;\n\nangular\n    .module(&#39;app&#39;, [])\n    .controller(&#39;mainController&#39;, MainController)\n    .service(&#39;searchService&#39;, SearchService);</code></pre></div>\n<p>We simply import the <code class=\"language-text\">MainController</code> in our <code class=\"language-text\">app.js</code> file that we use to bootstrap our application. In order to register it as a controller, we pass it on to Angular’s <code class=\"language-text\">controller()</code> method.</p>\n<h2>Angular and ES2015 inheritance</h2>\n<p>The good news is, you already know how to use it! We’ve already seen how easy inheritance becomes with ES2015 in our earlier example. Let’s create a <code class=\"language-text\">PageController</code> and a <code class=\"language-text\">ProductPageController</code> whereas the <code class=\"language-text\">PageController</code> simply defines a <code class=\"language-text\">title()</code> function that should be available in all controllers that derive from <code class=\"language-text\">PageController</code>. All it does is that it prepends the string <code class=\"language-text\">Title:</code> to the instance variable <code class=\"language-text\">_title</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class PageController {\n\n    constructor(title) {\n        this._title = title;\n    }\n\n    title () {\n        return &#39;Title: &#39; + this._title;\n    }\n}\nexport { PageController }</code></pre></div>\n<p>While it’s possible to just set <code class=\"language-text\">_title</code> to a string from within the constructor of our <code class=\"language-text\">ProductPageController</code> we are aiming for the cleaner way and instead pass it to the constructor of our <code class=\"language-text\">PageController</code> by calling <code class=\"language-text\">super(&#39;ES2015 inheritance with Angular&#39;);</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { PageController } from &#39;./PageController&#39;;\n\nclass ProductPageController extends PageController {\n\n    constructor() {\n        super(&#39;ES2015 inheritance with Angular&#39;);\n    }\n}\n\nexport { ProductPageController }</code></pre></div>\n<p>That’s probably not the most exciting example in the world but it works! All there’s left to do is to angularize the <code class=\"language-text\">ProductPageController</code>. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { ProductPageController } from &#39;./ProductPageController&#39;;\n\nangular\n    .module(&#39;app&#39;, [])\n    .controller(&#39;ProductPageController&#39;, ProductPageController);</code></pre></div>\n<p>Please note that we don’t have to do the same with the <code class=\"language-text\">PageController</code> as long as it’s not <em>explicitly</em> used as an Angular controller. In our case, it’s only used <em>implicitly</em> by the <code class=\"language-text\">ProductPageController</code>.</p>\n<p><strong>Edit:</strong> Evgeniy <a href=\"https://plus.google.com/+PascalPrecht/posts/Jre92W8GnJQ\">asked on G+</a>:</p>\n<blockquote>\n<p>“how can be ‘title’ argument in constructor of next controller be legit? It doesn’t look like the name of service”.﻿</p>\n</blockquote>\n<p>*The parameters in our constructor <strong>do</strong> work together with Angulars DI. In fact, the constructor is not different from a traditional constructor function. But how can <code class=\"language-text\">title</code> be legit then? The reason for that to work is that the <code class=\"language-text\">title</code> parameter is only used by the <code class=\"language-text\">PageController</code> which isn’t registered with <code class=\"language-text\">myModule.controller(fn)</code>. The <code class=\"language-text\">PageController</code> is only used implicitly by the <code class=\"language-text\">ProductPageController</code>.*</p>\n<p>Easy isn’t it? Can we use that for services, too? Yes, we can but there’s a small gotcha. It doesn’t work with services that are defined using the <code class=\"language-text\">myModule.factory(fn)</code> API but only for those that are defined using <code class=\"language-text\">myModule.service(fn)</code>. That’s because services that are defined using the <code class=\"language-text\">myModule.service(fn)</code> API are instantiated with the <code class=\"language-text\">new</code> operator under the hood whereas the others are not. For inheritance to work it’s important that our constructor function is instantiated with <code class=\"language-text\">new</code> though.</p>\n<p>There’s one more gotcha <a href=\"https://plus.google.com/+PascalPrecht/posts/Jre92W8GnJQ\">pointed out by Evgeniy</a>: When we use ES2015 classes we lose the ability to use explicit dependency annotation with the inline array notation.</p>\n<p>In order to preserve dependency annotations for minification, we need to use the <code class=\"language-text\">$inject</code> property notation now:</p>\n<p><code class=\"language-text\">MainController.$inject = [&#39;SearchService&#39;];</code></p>\n<h2>Getting started with our boilerplate</h2>\n<p>There are plenty of different ways to get started with ES2015 today. The sheer amount of different ways to approach it can be very confusing. At thoughtram we created a <a href=\"https://github.com/thoughtram/es6-babel-browserify-boilerplate\">boilerplate</a> that makes it quite easy to get rolling. It uses the popular <a href=\"https://babeljs.io/\">babel transpiler</a> to convert ES2015 to ES5 code that works in all current major browsers. The boilerplate also uses <a href=\"http://browserify.org/\">browserify</a> to concat and minify all ES2015 modules into a single file.</p>","frontmatter":{"author":"christoph_burgdorf","title":"Using ES2015 with Angular today","imageUrl":null,"date":"23 January 2015","summary":"One of the most exciting upcoming changes for Angular version 2.0.0 is that it's entirely written in ES2015 - the next version of JavaScript. There's no need to wait until Angular version 2.0.0 though. You can start writing your Angular apps with ES20152015 today - even with Angular 1.x. In this post we are going to look at two very exciting ES2015 features and how they can play a role in the context of an Angular application. Modules and Inheritance.","categories":["angularjs","es6"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/angularjs/es6/2015/01/23/exploring-angular-1.3-using-es6.html","previous":{"fields":{"slug":"/angularjs/2015/01/23/exploring-angular-1.3-ngMessages.html"},"frontmatter":{"date":"2015/01/23","title":"ngMessages in Angular 1.3","categories":["angularjs"]}},"next":{"fields":{"slug":"/git/rebase-book/2015/02/10/understanding-branches-in-git.html"},"frontmatter":{"date":"2015/02/10","title":"Understanding branches in Git","categories":["git","rebase-book"]}}}}}
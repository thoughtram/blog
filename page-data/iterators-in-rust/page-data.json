{"componentChunkName":"component---src-templates-blog-post-js","path":"/iterators-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"fec8b43a-232e-5b80-9466-0026936fe2ce","excerpt":"Whether you’re new to programming or have many years of experience in solving problems and implementing algorithms, chances are high you’ve heard about and used…","html":"<p>Whether you’re new to programming or have many years of experience in solving problems and implementing algorithms, chances are high you’ve heard about and used iterators at some point. Iterators are objects that produce sequences of values, so they can be iterated or looped over. Or, in other words, every time you ended up using a <code class=\"language-text\">for</code> loop in your program, you were most likely interacting with some kind of iterator.</p>\n<p>Obviously, Rust comes with support for loops and iterators as well, and, just like in many other languages, iterators can be implemented from scratch. In this article we’re going to take a closer look at the <code class=\"language-text\">Iterator</code> and <code class=\"language-text\">IntoIterator</code> traits to create iterators and turning existing types into iterators as well.</p>\n<h2>Understanding the <code class=\"language-text\">Iterator</code> trait</h2>\n<p>Alright, let’s start off by inspecting the following code snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Elvira\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Dominic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> names <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We’ve got a <code class=\"language-text\">Vec&lt;&amp;str&gt;</code> of names and print out each and every one of them by iterating over it with a <code class=\"language-text\">for</code> loop. Nothing too fancy going on here. Oh by the way, if you’re wondering what <code class=\"language-text\">&amp;str</code> means, check out this article about <a href=\"/string-vs-str-in-rust/\">String vs &#x26;str in Rust</a>.</p>\n<p>The next snippet is very similar:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> book_reviews <span class=\"token operator\">=</span> HashMap<span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbook_reviews<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"Search Inside Yourself\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"A great book about meditation.\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nbook_reviews<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span>\n    <span class=\"token string\">\"Limitless\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"Unleash the potential of your brain!\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> review <span class=\"token keyword\">in</span> book_reviews <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}: {}\"</span><span class=\"token punctuation\">,</span> review<span class=\"token number\">.0</span><span class=\"token punctuation\">,</span> review<span class=\"token number\">.1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This time however, we’re dealing with a <code class=\"language-text\">HashMap&lt;String, String&gt;</code>. Still, we’re able to simply iterate over <code class=\"language-text\">book_reviews</code>, how come that’s possible? You’ve probably already guessed that there’s some mechanism in place that ensures Rust treats these types as something we can iterate over. There are some things going on here, but the first important bit is that <code class=\"language-text\">for</code> loops consume any type that implement the <code class=\"language-text\">Iterator</code> trait.</p>\n<p>Here’s what it looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">trait</span> Iterator <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> Item<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Option<span class=\"token operator\">&lt;</span><span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span>Item<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">Iterator</code> trait comes with a <code class=\"language-text\">next()</code> method that returns <code class=\"language-text\">Option&lt;Self::Item&gt;</code>. The exact type of <code class=\"language-text\">Self::Item</code> depends on the values the iterator produces. What’s more interesting however, is that it’s wrapped in an <code class=\"language-text\">Option</code>. <code class=\"language-text\">next()</code> returns the next value of the iterator and because it could potentially run out of values, returning an <code class=\"language-text\">Option</code> enables the API to return <code class=\"language-text\">None</code> in such cases. This also means that iterators are stateful because they keep track of where they are in the iteration process. There are some more methods attached to the trait but we can ignore those for now.</p>\n<p>Okay cool, we use <code class=\"language-text\">Vec&lt;T&gt;</code> and <code class=\"language-text\">HashMap&lt;K, V&gt;</code> (and other collection types) in <code class=\"language-text\">for</code> loops so they most likely implement the <code class=\"language-text\">Iterator</code> trait. However if we try to call <code class=\"language-text\">next()</code> on them like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Elvira\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Dominic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nnames<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>We’ll get a compiler error telling us that there’s no such API:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0599]: no method named `next` found for struct `std::vec::Vec&lt;&amp;str&gt;` in the current scope\n --&gt; src/main.rs:9:11\n  |\n9 |     names.next();\n  |           ^^^^ method not found in `std::vec::Vec&lt;&amp;str&gt;`</code></pre></div>\n<p>What’s going on here? Well, it turns out that there’s another trait in place that ensures our loop indeed receives an <code class=\"language-text\">Iterator</code>. That trait is the <code class=\"language-text\">IntoIterator</code> trait.</p>\n<h2>Iterables with <code class=\"language-text\">IntoIterator</code></h2>\n<p>When there’s a “natural way” to iterate over some type, it can implement the <code class=\"language-text\">IntoIterator</code> trait. <code class=\"language-text\">IntoIterator</code> comes with an <code class=\"language-text\">into_iter()</code> method that returns an iterator over its value. Here’s what it looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">trait</span> IntoIterator <span class=\"token keyword\">where</span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span>IntoIter<span class=\"token punctuation\">::</span>Item <span class=\"token operator\">==</span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span>Item <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> Item<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">type</span> IntoIter<span class=\"token punctuation\">:</span> Iterator<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">into_iter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span><span class=\"token punctuation\">::</span>IntoIter<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Any type that implements <code class=\"language-text\">IntoIterator</code> is also called an <strong>Iterable</strong>. So how does this trait play a role in the original scenario we’ve discussed? If we have a <code class=\"language-text\">for</code> loop that looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Elvira\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Dominic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> names <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>It actually desugars to something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> iterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">into_iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token keyword\">let</span> <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Aha! Our <code class=\"language-text\">for</code> loop actually takes care of turning an Iterable into an Iterator by calling <code class=\"language-text\">into_iter()</code> on it! This also works when iterators are passed directly to <code class=\"language-text\">for</code> loops, because any type that implements <code class=\"language-text\">Iterator</code> also implements <code class=\"language-text\">IntoIterator</code>, which then just simply returns the iterator itself:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Elvira\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Dominic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> iterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">into_iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> name <span class=\"token keyword\">in</span> iterator <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Obviously, in this particular case there’s no additional value in doing that. However, when we deal with types like <code class=\"language-text\">Range</code> and other iterator types, everything works just as expected. If you’re curious about what other built-in iterator types are there, keep on reading!</p>\n<h2>Creating iterator using <code class=\"language-text\">iter()</code> and <code class=\"language-text\">iter_mut()</code></h2>\n<p>There are actually different ways in Rust to create iterators from types. While the <code class=\"language-text\">IntoIterator</code> and its <code class=\"language-text\">into_iter()</code> method are mostly called implicitly when we use <code class=\"language-text\">for</code> loops, <code class=\"language-text\">iter()</code> and <code class=\"language-text\">iter_mut()</code> methods are often provided by collection types to create iterators explicitly. There’s no trait that provides <code class=\"language-text\">iter()</code> and <code class=\"language-text\">iter_mut()</code>, so it’s more of a convention that collection types may implement these methods. </p>\n<p>The example from above can then be written as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Elvira\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Dominic\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> iterator <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>names<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// or iter_mut() respectively</span>\n\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>So what’s the point of having <code class=\"language-text\">iter()</code> und <code class=\"language-text\">iter_mut()</code> when there’s <code class=\"language-text\">into_iter()</code>, which seems to do the same thing? As always, the devil is in the details as <a href=\"https://stackoverflow.com/a/34745885/1531806\">this StackOverFlow answer</a> illustrates very nicely.</p>\n<p>As mentioned before, <code class=\"language-text\">IntoIterator</code> implementations mostly come into play in combination with <code class=\"language-text\">for</code> loops. One thing to keep in mind here, is that we probably want the flexibility to consume our iterable values to be by value <strong>or</strong> (mutable) reference depending on our context. </p>\n<p>If this doesn’t make a lot of sense to you, you might want to read this article on <a href=\"/references-in-rust\">References in Rust</a> and come back once you’re done.</p>\n<p>In other words, we want to be able to any of the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">for</span> element <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span>collection <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">for</span> element <span class=\"token keyword\">in</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> collection <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">for</span> element <span class=\"token keyword\">in</span> collection <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">...</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">IntoIterator</code> trait allows for that. For example, if we look at the implementation of <code class=\"language-text\">Vec&lt;T&gt;</code> it implements the trait three times:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> IntoIterator <span class=\"token keyword\">for</span> Vec<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span>\n<span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a,</span> T<span class=\"token operator\">></span> IntoIterator <span class=\"token keyword\">for</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> Vec<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span>\n<span class=\"token keyword\">impl</span><span class=\"token operator\">&lt;</span><span class=\"token lifetime-annotation symbol\">'a,</span> T<span class=\"token operator\">></span> IntoIterator <span class=\"token keyword\">for</span> <span class=\"token operator\">&amp;</span><span class=\"token lifetime-annotation symbol\">'a</span> <span class=\"token keyword\">mut</span> Vec<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span></code></pre></div>\n<p>Depending on how we use <code class=\"language-text\">into_iter()</code> on a <code class=\"language-text\">Vec&lt;T&gt;</code> we’ll get different types of values produced, namely values of <code class=\"language-text\">T</code>, <code class=\"language-text\">&amp;T</code> or <code class=\"language-text\">&amp;mut T</code> respectively (as illustrated in the three <code class=\"language-text\">for</code> loops above). Keep in mind though, that this only works because <code class=\"language-text\">Vec&lt;T&gt;</code> happens to implement <code class=\"language-text\">IntoIterator</code> for these three scenarios. There are other types, that only come with one or two implementations of <code class=\"language-text\">IntoIterator</code>, which might lead to surprising results when relying on <code class=\"language-text\">into_iter()</code> directly.</p>\n<p>This is different when we use <code class=\"language-text\">iter()</code> or <code class=\"language-text\">iter_mut()</code>. These two methods always return immutable references (<code class=\"language-text\">&amp;T</code>) or mutable references (<code class=\"language-text\">&amp;mut T</code>) but never values, making these APIs very predictable. </p>\n<p>In short:</p>\n<ul>\n<li>Given a shared reference to a collection, <code class=\"language-text\">into_iter()</code> returns an iterator that produces shared references to its items.</li>\n<li>Given a mutable reference to a collection, it returns an iterator that produces mutable references to the items.</li>\n<li>Given a collection as value, it returns an iterator that takes <strong>ownership</strong> of the collection and returns items by value. For a quick primer on ownership, check out <a href=\"/ownership-in-rust/\">this article</a>.</li>\n<li><code class=\"language-text\">iter()</code> always returns an iterator that produces shared references to its items.</li>\n<li><code class=\"language-text\">iter_mut()</code> always returns an iterator that produces mutable references to its items.</li>\n</ul>\n<h2>What else is there?</h2>\n<p>So far we’ve discussed what iterators are and how we create them, but obviously, there’s more to them. The real power of iterators emerges when we leverage the power of <strong>Iterator adapters</strong>, which are functional APIs that enable us to build new iterators with specific characteristics. We’ll take a closer look at the most important ones in another article, so stay tuned and sign up to the <a href=\"/categories/rust\">Rust For JavaScript Developers</a> newsletter!</p>","frontmatter":{"author":"pascal_precht","title":"Iterators in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwT/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABoVkYzkA//8QAGxAAAQQDAAAAAAAAAAAAAAAAEQABEiECIjH/2gAIAQEAAQUCEW6sm2NVIL//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAdEAABAwUBAAAAAAAAAAAAAAAAASExAhARQVFh/9oACAEBAAY/AjXCEM0t4OkJb//EAB0QAAICAgMBAAAAAAAAAAAAAAERACExcUFRYYH/2gAIAQEAAT8h1BqEGgZlLjio3MtwfDllQeLuFjl+z//aAAwDAQACAAMAAAAQNz//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEAAQUBAQEAAAAAAAAAAAABEQAhMUFRgZHw/9oACAEBAAE/EACIgZlH0q8KZj75rypYBmwv1qEp2MrJTAc28oLz+HXf1abZ7wvX/9k=","aspectRatio":1.3333333333333333,"src":"/static/bb2a19b4d4a10399b128fefae50efa37/30037/windows.jpg","srcSet":"/static/bb2a19b4d4a10399b128fefae50efa37/10bdc/windows.jpg 158w,\n/static/bb2a19b4d4a10399b128fefae50efa37/f4ab0/windows.jpg 315w,\n/static/bb2a19b4d4a10399b128fefae50efa37/30037/windows.jpg 630w,\n/static/bb2a19b4d4a10399b128fefae50efa37/9810d/windows.jpg 945w,\n/static/bb2a19b4d4a10399b128fefae50efa37/ff2e4/windows.jpg 1260w,\n/static/bb2a19b4d4a10399b128fefae50efa37/14dee/windows.jpg 1920w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"08 October 2020","summary":"Explore the power and flexibility of Iterators to produce sequences of values you can loop over.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/iterators-in-rust/","previous":{"fields":{"slug":"/references-in-rust/"},"frontmatter":{"date":"2020/03/17","title":"References in Rust","categories":["rust"]}},"next":{"fields":{"slug":"/lifetimes-in-rust/"},"frontmatter":{"date":"2020/10/20","title":"Lifetimes in Rust","categories":["rust"]}}}}}
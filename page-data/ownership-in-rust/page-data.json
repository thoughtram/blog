{"componentChunkName":"component---src-templates-blog-post-js","path":"/ownership-in-rust/","webpackCompilationHash":"0c5d630095500f933ccd","result":{"data":{"site":{"siteMetadata":{"title":"Articles by thoughtram","authors":[{"id":"pascal_precht","name":"Pascal Precht","twitter":"PascalPrecht","img":"https://avatars2.githubusercontent.com/u/445106?s=460&v=4"},{"id":"christoph_burgdorf","name":"Christoph Burgdorf","twitter":"cburgdorf","img":"https://avatars0.githubusercontent.com/u/521109?s=460&v=4"},{"id":"dominic_elm","name":"Dominic Elm","twitter":"d3lm","img":"https://avatars0.githubusercontent.com/u/12571019?s=400&v=4"},{"id":"thomas_burleson","name":"Thomas Burleson","twitter":"thomasburleson","img":"https://avatars3.githubusercontent.com/u/210413?s=400&v=4"},{"id":"elvira_eulitz","name":"Elvira Eulitz","twitter":"ElviraEulitz","img":"https://avatars3.githubusercontent.com/u/29247040?s=400&v=4"},{"id":"maxim_koretskyi","name":"Maxim Koretskyi","twitter":"maxim_koretskyi","img":"https://avatars3.githubusercontent.com/u/6124091?s=400&v=4"}]}},"markdownRemark":{"id":"553ab7b2-57ed-57f6-8d88-3477011255a3","excerpt":"So you want to learn Rust and keep hearing about the concept of Ownership and Borrowing, but can’t fully wrap your head around what it is. Ownership is so…","html":"<p>So you want to learn Rust and keep hearing about the concept of Ownership and Borrowing, but can’t fully wrap your head around what it is. Ownership is so essential that it’s good to understand it early on in your journey of learning Rust, also to avoid running into compiler errors that keep you from implementing your programs.</p>\n<p>In our <a href=\"/rust/2015/05/11/rusts-ownership-model-for-javascript-developers.html\">previous</a> article, we’ve already talked about the Ownership model from a JavaScript developer’s perspective. In this article we’ll take a closer look at how Rust manages memory and why this ultimately affects how we write our code in Rust and preserve memory safety.</p>\n<p>Once you’re done reading this, you might want to check out our article on <a href=\"/references-in-rust\">References in Rust</a> as well as the <a href=\"/string-vs-str-in-rust\">difference between String and &#x26;str</a>.</p>\n<h2>What is Memory Safety anyway?</h2>\n<p>First and foremost it’s good to understand what memory safety actually means when it comes to discussing what makes Rust stand out as a programming language. Especially when coming from a non-systems programming background, or with mainly experience in garbage collected languages, it might be a bit harder to appreciate this fundamental feature of Rust.</p>\n<p>As Will Crichton states in his great article <a href=\"http://willcrichton.net/notes/rust-memory-safety/\">Memory Safety in Rust: A Case Study with C</a>:</p>\n<p>”<em>Memory safety is the property of a program where memory pointers used always point to valid memory, i.e. allocated and of the correct type/size. Memory safety is a correctness issue—a memory unsafe program may crash or produce nondeterministic output depending on the bug.</em>”</p>\n<p>In practice, this means that there are languages that allow us to write “memory unsafe” code, in the sense that it’s fairly easy to introduce bugs. Some of those bugs are:</p>\n<ul>\n<li><strong>Dangling pointers</strong>: Pointers that point to invalid data (this will make more sense once we look at how data is stored in memory). You can read more about dangling pointers <a href=\"https://stackoverflow.com/questions/17997228/what-is-a-dangling-pointer\">here</a>.</li>\n<li><strong>Double frees</strong>: Trying to free the same memory location twice, which can lead to “undefined behaviour”. More on that <a href=\"https://stackoverflow.com/questions/21057393/what-does-double-free-mean\">here</a>.</li>\n</ul>\n<p>To illustrate the concept of a dangling pointer, let’s take a look at the following <strong>C++ code</strong> and how it is represented in memory:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">std<span class=\"token operator\">::</span>string s <span class=\"token operator\">=</span> <span class=\"token string\">\"Have a nice day\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The initialized string is usually represented in memory using the <strong>stack</strong> and <strong>heap</strong> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">                     buffer\n                   /   capacity\n                 /   /    length\n               /   /    /\n            +–––+––––+––––+\nstack frame │ • │ 16 │ 15 │ &lt;– s\n            +–│–+––––+––––+\n              │\n            [–│––––––––––––––––––––––––– capacity ––––––––––––––––––––––––––]\n              │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+\n       heap │ H │ a │ v │ e │   │ a │   │ n │ i │ c │ e │   │ d │ a │ y │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+\n\n            [––––––––––––––––––––––––– length ––––––––––––––––––––––––––]</code></pre></div>\n<p>We’ll get into what stack and heap are in a second, but for now it’s important to appreciate that what gets stored on the stack is the <code class=\"language-text\">std::string</code> object itself which is of a three words long, fixed size. The fields are a pointer to the <strong>heap-allocated</strong> buffer which holds the actual data, the buffers capacity and the length of the text. In other words, the <code class=\"language-text\">std::string</code> <strong>owns</strong> its buffer. When the program destroys this string, it’ll free the corresponding buffer as well through the string’s destructor.</p>\n<p>However, it’s totally possible to create other pointer objects to a character living inside that same buffer which won’t get destroyed as well, leaving them invalid after the string has been destroyed, and there we have it - a dangling pointer!</p>\n<p>If you wonder how this is not exactly an issue when you write programs in languages like JavaScript or Python, the reason for that is that those languages are <strong>garbage collected</strong>. This means that the language comes with a program that, at run-time, will traverse the memory and free everything up that is no longer in use. Such program is called a Garbage Collector. While this sounds like a nice thing to have, of course garbage collection comes at a cost. Since it happens at run-time of your program, it can certainly affect the program’s overall run-time performance.</p>\n<p>Rust does not come with garbage collection, instead, it solves the issue of guaranteeing memory safety using ownership and borrowing. When we say that Rust comes with memory safety, we refer to the fact that, by default, <strong>Rust’s compiler doesn’t even allow us to write code that is not memory safe</strong>. How cool is that?</p>\n<h2>Stack and Heap</h2>\n<p>Before we jump into how Rust handles Ownership of data, let’s quickly touch on what the stack and heap are and how they relate to which data gets stored where.</p>\n<p>Both, stack and heap, are parts of memory but are represented in different data structures. While the stack is… well, a stack, where values are stored in order as they come in, and removed in the opposite order (which are very fast operations), a heap is more like a tree structure that requires a bit more computational effort to read and write data.</p>\n<p>What goes onto the stack and what onto the heap depends on what data we’re dealing with. In Rust, any data of fixed size (or “known” size at compile time), such as machine integers, floating-point numeric types, <strong>pointer types</strong> and a few others, are stored on the stack. Dynamic and “unsized” data is stored on the heap. This is because often these types of unkown size either need to be able to to dynamically grow, or because they need to do certain “clean up” work when destructed (more than just popping a value off the stack).</p>\n<p>That’s why in the previous example, the string object itself is actually a pointer stored on the stack, which is always of fixed size (a buffer pointer, capacity and length), whereas the buffer (the raw data) is stored on the heap.</p>\n<p>As for Rust, generally the language avoids storing data on the heap and the compiler will never <strong>implicitly</strong> do so either. To make it explicit, Rust comes with certain pointer types such as <a href=\"https://doc.rust-lang.org/book/ch15-02-deref.html?highlight=Box%3CT%3E#defining-our-own-smart-pointer\">Box<T></a>, which we’ll cover in another article. For more information on stack and heap I highly recommend taking a look at <a href=\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\">Rust’s official chapter on Ownership</a>.</p>\n<h2>Understanding Ownership</h2>\n<p>Now that we have a little bit of a better understanding of how data is stored, let’s take a closer look at Ownership in Rust. In Rust, every value has a single owner that determines its lifetime. If we take the C++ code from above and look at the Rust equivalent, the data is stored in memory pretty much the same way.</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"Have a nice day\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Similarly, when the owner of some value is “freed”, or in Rust lingo, “dropped”, the owned value is dropped as well. When are values dropped? This is where it gets interesting. When the program leaves a block in which a variable is declared, that variable will be dropped, dropping its value with it.</p>\n<p>A block could be a function, an if statement, or pretty much anything that introduces a new code block with curly braces. Assuming we have the following function:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> s <span class=\"token operator\">=</span> <span class=\"token string\">\"Have a nice day\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// `s` is dropped here</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Just by looking at the code, we know the lifetime of <code class=\"language-text\">s</code> because we know that Rust will drop its value when it reaches the end of the function block. The same applies when we deal with more complex data structures. Let’s take a look at the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> names <span class=\"token operator\">=</span> <span class=\"token function\">vec!</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Christoph\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This creates a vector of names. A vector in Rust is like an array, or list, but it’s dynamic in size. We can <code class=\"language-text\">push()</code> values into it at run-time. Our memory will look something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            [–– names ––]\n            +–––+–––+–––+\nstack frame │ • │ 3 │ 2 │\n            +–│–+–––+–––+\n              │\n            [–│–– 0 –––] [–––– 1 ––––]\n            +–V–+–––+–––+–––+––––+–––+–––+–––+\n       heap │ • │ 8 │ 6 │ • │ 12 │ 9 │       │\n            +–│–+–––+–––+–│–+––––+–––+–––+–––+\n              │\\   \\   \\  │\n              │ \\   \\    length\n              │  \\    capacity\n              │    buffer │\n              │           │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+\n            │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+\n                          │\n                          │\n                        +–V–+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+\n                        │ C │ h │ r │ i │ s │ t │ o │ p │ h │   │   │   │\n                        +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>Notice how the vector object itself, similar to the string object earlier, is stored on the stack with its capacity, and length. It also comes with a pointer, pointing at the location in the heap where the vector data is located. The string objects of the vector are then stored on the heap, which in turn own their dedicated buffer.</p>\n<p>This creates a tree structure of data where every value is owned by a single variable. When <code class=\"language-text\">names</code> goes out of scope, its values will be dropped which eventually cause the string buffers to be dropped as well.</p>\n<p>This probably raises a couple of questions though. How does Rust ensure that only a single variable owns its value? How can we have multiple variables point at the same data? Are we forced to copy everything to ensure only a single variable owns some value?</p>\n<h2>Moves and Borrowing</h2>\n<p>Let’s start with the first question: How does Rust ensure that only a single variable owns its value? It turns out that Rust <strong>moves</strong> values to their new owner when doing things like value assignment or passing values to functions. This is a very important concept as it affects how we write code in Rust.</p>\n<p>Let’s take a look at the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Coming from languages like Python or JavaScript, we’d probably expect that both <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> will have a reference to <code class=\"language-text\">name</code> and therefore will both point at the same data. However, when we try to compile this code, we soon realize that this is not the case:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">error[E0382]: use of moved value: `name`\n --&gt; src/main.rs:4:11\n  |\n2 |   let name = &quot;Pascal&quot;.to_string();\n  |       ---- move occurs because `name` has type `std::string::String`, which does not implement the `Copy` trait\n3 |   let a = name;\n  |           ---- value moved here\n4 |   let b = name;\n  |           ^^^^ value used here after move</code></pre></div>\n<p>We get a compiler error with a lot of (useful) information. The compiler tells us that we’re trying to assign the value from <code class=\"language-text\">name</code> to <code class=\"language-text\">b</code> <strong>after</strong> it had been moved to <code class=\"language-text\">a</code>. The problem here is that, by the time we’re trying to assign the value of <code class=\"language-text\">name</code> to <code class=\"language-text\">b</code>, <code class=\"language-text\">name</code> doesn’t actually own the value anymore. Why? Because ownership has been moved to <code class=\"language-text\">a</code> in the meantime.</p>\n<p>Let’s take a look at what happens in memory to get a better understanding of what’s going on. When <code class=\"language-text\">name</code> is initialized, it looks very similar to our examples earlier:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            +–––+–––+–––+\nstack frame │ • │ 8 │ 6 │ &lt;– name\n            +–│–+–––+–––+\n              │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>However, when we assign the value of <code class=\"language-text\">name</code> to <code class=\"language-text\">a</code>, we <strong>move</strong> ownership to <code class=\"language-text\">a</code> as well, leaving <code class=\"language-text\">name</code> uninitialized:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            [–– name ––] [––– a –––]\n            +–––+–––+–––+–––+–––+–––+\nstack frame │   │   │   │ • │ 8 │ 6 │ \n            +–––+–––+–––+–│–+–––+–––+\n                          │\n              +–––––––––––+\n              │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>At this point, it’s no surprise that the expession <code class=\"language-text\">let b = name</code> will result in an error. What’s important to appreciate here is that all of this is static analysis done by the compiler without actually running our code!</p>\n<p>Remember when I said Rust’s compiler doesn’t allow us to write memory unsafe code?</p>\n<p>So how do we handle cases like these? What if we really want to have multiple variables point at the same data? There are two ways to deal with this, and depending on the case we want to go with one or the other. Probably the easiest but also most costly way to handle this scenario is to copy or clone the value. Obviously, that also means we’ll end up duplicating the data in memory:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Notice that we don’t need to clone the value from <code class=\"language-text\">name</code> into <code class=\"language-text\">a</code> because we’re not trying to read a value from <code class=\"language-text\">name</code> after its value has been assigned to <code class=\"language-text\">a</code>. When we run this program, the data will be represented in memory like this before its dropped:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">            [–– name ––] [––– a –––][–––– b ––––]\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+\nstack frame │   │   │   │ • │ 8 │ 6 │ • │ 8 │ 6 │\n            +–––+–––+–––+–│–+–––+–––+–│–+–––+–––+\n                          │           │\n              +–––––––––––+           +–––––––+\n              │                               │\n            +–V–+–––+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+\n       heap │ P │ a │ s │ c │ a │ l │   │   │ P │ a │ s │ c │ a │ l │   │   │\n            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</code></pre></div>\n<p>Obviously, cloning data isn’t always an option. Depending on what data we’re dealing with, this can be a quite expensive operation with a lot of memory preassure. Often, all we really need is a <strong>reference</strong> to a value. This is especially useful when we write functions that don’t actually need ownership of a value. Imagine a function <code class=\"language-text\">greet()</code> that takes a name and simply outputs it:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn greet(name: String) {\n  println!(&quot;Hello, {}!&quot;, name);\n}</code></pre></div>\n<p>This function doesn’t need ownership to output the value it takes. Also, it would prevent us from calling the function multiple times with the same variable:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Move happened earlier so this won't compile</span></code></pre></div>\n<p>To get a reference to a variable we use the <code class=\"language-text\">&amp;</code> symbol. With that we can be explict about when we expect a reference over a value:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn greet(name: &amp;String) {\n  println!(&quot;Hello, {}!&quot;, name);\n}</code></pre></div>\n<p>For the record, we would probably design this API to expect a <code class=\"language-text\">&amp;str</code> instead for various reasons, but I don’t want to make it more confusing as it needs to be so we’ll just stick with a <code class=\"language-text\">&amp;String</code> for now.</p>\n<p><code class=\"language-text\">greet()</code> now expects a string reference, which also enables us to call it multiple times like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>When a function expects a reference to a value, it *<em>borrows</em> it. Notice that it never gets ownership of the values that are being passed to it.</p>\n<p>We can address the variable assignment from earlier in a similar fashion:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">;</span></code></pre></div>\n<p>With this code, <code class=\"language-text\">name</code> never loses ownership of its value and <code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are just pointers to the same data. The same can be expressed with:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Calling <code class=\"language-text\">greet()</code> in between those assignments is no longer problem either:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Pascal\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token function\">greet</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Conclusion</h2>\n<p>This was really just the tip of the iceberg. There are a few more things to consider when it comes to Ownership, Borrowing and Moving data, but hopefully this article conveys a good basic understanding of what’s going on behind the scenes on how Rust ensures memory safety.</p>\n<p>More articles on Rust to come!</p>","frontmatter":{"author":"pascal_precht","title":"A closer look at Ownership in Rust","imageUrl":{"childImageSharp":{"sizes":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHh6iyIP//EABgQAAMBAQAAAAAAAAAAAAAAAAABEhEC/9oACAEBAAEFAly2QSUzWaf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAEBAQAAAAAAAAAAAAAAAAAAMSD/2gAIAQEABj8CVcf/xAAaEAACAwEBAAAAAAAAAAAAAAAAAREhcUFR/9oACAEBAAE/IfEWmY0Cgqpoi6SP/9oADAMBAAIAAwAAABB03//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAARIf/aAAgBAgEBPxCMf//EABwQAQACAgMBAAAAAAAAAAAAAAEAESFxMUFRsf/aAAgBAQABPxBznYqIDKaIBr4gM3YryCMOLKt3uf/Z","aspectRatio":1.502824858757062,"src":"/static/255fa5890bff55ae77d29bbaff941ee2/30037/earth-from-space.jpg","srcSet":"/static/255fa5890bff55ae77d29bbaff941ee2/10bdc/earth-from-space.jpg 158w,\n/static/255fa5890bff55ae77d29bbaff941ee2/f4ab0/earth-from-space.jpg 315w,\n/static/255fa5890bff55ae77d29bbaff941ee2/30037/earth-from-space.jpg 630w,\n/static/255fa5890bff55ae77d29bbaff941ee2/9810d/earth-from-space.jpg 945w,\n/static/255fa5890bff55ae77d29bbaff941ee2/ff2e4/earth-from-space.jpg 1260w,\n/static/255fa5890bff55ae77d29bbaff941ee2/950ca/earth-from-space.jpg 4256w","sizes":"(max-width: 630px) 100vw, 630px"}}},"date":"28 October 2019","summary":"In this article we'll take a closer look at Rust's Ownership model and how it manages memory.","categories":["rust"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/ownership-in-rust/","previous":{"fields":{"slug":"/announcements/2019/09/02/more-GDE-power-at-thoughtram.html"},"frontmatter":{"date":"2019/09/02","title":"More GDE power at thoughtram","categories":["announcements"]}},"next":{"fields":{"slug":"/resurrecting-rebase/"},"frontmatter":{"date":"2019/12/16","title":"Announcing the REBASE ebook","categories":["git"]}}}}}